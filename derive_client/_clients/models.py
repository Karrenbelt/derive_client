# generated by datamodel-codegen:
#   filename:  RESTAPI-v2_0-latest.json
#   timestamp: 2025-09-21T21:35:39+00:00

from __future__ import annotations

import uuid
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field


class Status(str, Enum):
    unseen = "unseen"
    seen = "seen"
    hidden = "hidden"


class TypeEnum(str, Enum):
    deposit = "deposit"
    withdraw = "withdraw"
    transfer = "transfer"
    trade = "trade"
    settlement = "settlement"
    liquidation = "liquidation"
    custom = "custom"


class PrivateGetNotificationsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    page: Optional[int] = Field(
        1, description="Page number of results to return", title="page"
    )
    page_size: Optional[int] = Field(
        50,
        description="Number of results per page (must be between 0-50)",
        title="page_size",
    )
    status: Optional[Status] = Field(
        None, description="Status of the notification", title="status"
    )
    subaccount_id: Optional[int] = Field(
        None,
        description="Subaccount_id (must be set if wallet param is not set)",
        title="subaccount_id",
    )
    type: Optional[List[TypeEnum]] = Field(
        None, description="List of notification types to filter by", title="type"
    )
    wallet: Optional[str] = Field(
        None,
        description="Wallet address (if set, subaccount_id ignored)",
        title="wallet",
    )


class NotificationResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    event: str = Field(
        ...,
        description="The specific event leading to the notification.",
        title="event",
    )
    event_details: Dict[str, Any] = Field(
        ...,
        description="A JSON-structured dictionary containing detailed data or context about the event.",
        title="event_details",
    )
    id: int = Field(
        ..., description="The unique identifier for the notification.", title="id"
    )
    status: str = Field(
        ...,
        description="The status of the notification, indicating if it has been read, pending, or processed.",
        title="status",
    )
    subaccount_id: int = Field(
        ...,
        description="The subaccount_id associated with the notification.",
        title="subaccount_id",
    )
    timestamp: int = Field(
        ...,
        description="The timestamp indicating when the notification was created or triggered.",
        title="timestamp",
    )
    transaction_id: Optional[int] = Field(
        None,
        description="The transaction id associated with the notification.",
        title="transaction_id",
    )
    tx_hash: Optional[str] = Field(
        None,
        description="The transaction hash associated with the notification.",
        title="tx_hash",
    )


class PaginationInfoSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    count: int = Field(
        ..., description="Total number of items, across all pages", title="count"
    )
    num_pages: int = Field(..., description="Number of pages", title="num_pages")


class PublicGetCurrencyParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(
        ...,
        description="Underlying currency of asset (`ETH`, `BTC`, etc)",
        title="currency",
    )


class InstrumentType(str, Enum):
    erc20 = "erc20"
    option = "option"
    perp = "perp"


class MarketType(str, Enum):
    ALL = "ALL"
    SRM_BASE_ONLY = "SRM_BASE_ONLY"
    SRM_OPTION_ONLY = "SRM_OPTION_ONLY"
    SRM_PERP_ONLY = "SRM_PERP_ONLY"
    CASH = "CASH"


class OpenInterestStatsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    current_open_interest: Decimal = Field(
        ...,
        description="Current open interest for the margin type",
        title="current_open_interest",
    )
    interest_cap: Decimal = Field(
        ..., description="Total open interest cap", title="interest_cap"
    )
    manager_currency: Optional[str] = Field(
        None,
        description="Currency of the manager (only applies to Portfolio Margin)",
        title="manager_currency",
    )


class MarginType(str, Enum):
    PM = "PM"
    SM = "SM"
    PM2 = "PM2"


class ManagerContractResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    address: str = Field(..., description="Address of the manager", title="address")
    currency: Optional[str] = Field(
        None,
        description="Currency of the manager (only applies to portfolio managers)",
        title="currency",
    )
    margin_type: MarginType = Field(
        ..., description="Margin type of the manager", title="margin_type"
    )


class PM2CollateralDiscountsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    im_discount: Decimal = Field(
        ...,
        description="Initial Margin discount for given collateral in PM2",
        title="im_discount",
    )
    manager_currency: str = Field(
        ..., description="Currency of the manager", title="manager_currency"
    )
    mm_discount: Decimal = Field(
        ...,
        description="Maintenance Margin discount for given collateral in PM2",
        title="mm_discount",
    )


class ProtocolAssetAddressesSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    option: Optional[str] = Field(
        None,
        description="Address of the Derive protocol option contract (none if not supported)",
        title="option",
    )
    perp: Optional[str] = Field(
        None,
        description="Address of the Derive protocol perp contract (none if not supported)",
        title="perp",
    )
    spot: Optional[str] = Field(
        None,
        description="Address of the Derive protocol spot contract (none if not supported)",
        title="spot",
    )
    underlying_erc20: Optional[str] = Field(
        None,
        description="Address of the erc20 asset on Derive chain. This is the asset that is deposited into the spot asset",
        title="underlying_erc20",
    )


class PrivateSetMmpConfigParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(
        ..., description="Currency of this mmp config", title="currency"
    )
    mmp_amount_limit: Decimal = Field(
        "0",
        description="Maximum total order amount that can be traded within the mmp_interval across all instruments of the provided currency. The amounts are not netted, so a filled bid of 1 and a filled ask of 2 would count as 3.<br />Default: 0 (no limit)",
        title="mmp_amount_limit",
    )
    mmp_delta_limit: Decimal = Field(
        "0",
        description="Maximum total delta that can be traded within the mmp_interval across all instruments of the provided currency. This quantity is netted, so a filled order with +1 delta and a filled order with -2 delta would count as -1<br />Default: 0 (no limit)",
        title="mmp_delta_limit",
    )
    mmp_frozen_time: int = Field(
        ...,
        description="Time interval in ms setting how long the subaccount is frozen after an mmp trigger, if 0 then a manual reset would be required via private/reset_mmp",
        title="mmp_frozen_time",
    )
    mmp_interval: int = Field(
        ...,
        description="Time interval in ms over which the limits are monotored, if 0 then mmp is disabled",
        title="mmp_interval",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to set the config",
        title="subaccount_id",
    )


PrivateSetMmpConfigResultSchema = PrivateSetMmpConfigParamsSchema


class Direction(str, Enum):
    buy = "buy"
    sell = "sell"


class TradeModuleParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Order amount in units of the base", title="amount"
    )
    direction: Direction = Field(..., description="Order direction", title="direction")
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    limit_price: Decimal = Field(
        ...,
        description="Limit price in quote currency.<br />This field is still required for market orders because it is a component of the signature. However, market orders will not leave a resting order in the book in case of a partial fill.",
        title="limit_price",
    )
    max_fee: Decimal = Field(
        ...,
        description="Max fee per unit of volume, denominated in units of the quote currency (usually USDC).Order will be rejected if the supplied max fee is below the estimated fee for this order.",
        title="max_fee",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_3_digits> (e.g. 1695836058725001, where 001 is the random number).Note, using a random number beyond 3 digits will cause JSON serialization to fail.",
        title="nonce",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the order", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Order signature becomes invalid after this time, and the system will cancel the order.Expiry MUST be at least 5 min from now.",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed order",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class CancelReason(str, Enum):
    field_ = ""
    user_request = "user_request"
    mmp_trigger = "mmp_trigger"
    insufficient_margin = "insufficient_margin"
    signed_max_fee_too_low = "signed_max_fee_too_low"
    cancel_on_disconnect = "cancel_on_disconnect"
    ioc_or_market_partial_fill = "ioc_or_market_partial_fill"
    session_key_deregistered = "session_key_deregistered"
    subaccount_withdrawn = "subaccount_withdrawn"
    compliance = "compliance"
    trigger_failed = "trigger_failed"
    validation_failed = "validation_failed"


class OrderStatus(str, Enum):
    open = "open"
    filled = "filled"
    cancelled = "cancelled"
    expired = "expired"
    untriggered = "untriggered"


class OrderType(str, Enum):
    limit = "limit"
    market = "market"


class TimeInForce(str, Enum):
    gtc = "gtc"
    post_only = "post_only"
    fok = "fok"
    ioc = "ioc"


class TriggerPriceType(str, Enum):
    mark = "mark"
    index = "index"


class TriggerType(str, Enum):
    stoploss = "stoploss"
    takeprofit = "takeprofit"


class OrderResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Order amount in units of the base", title="amount"
    )
    average_price: Decimal = Field(
        ..., description="Average fill price", title="average_price"
    )
    cancel_reason: CancelReason = Field(
        ...,
        description="If cancelled, reason behind order cancellation",
        title="cancel_reason",
    )
    creation_timestamp: int = Field(
        ...,
        description="Creation timestamp (in ms since Unix epoch)",
        title="creation_timestamp",
    )
    direction: Direction = Field(..., description="Order direction", title="direction")
    filled_amount: Decimal = Field(
        ..., description="Total filled amount for the order", title="filled_amount"
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    is_transfer: bool = Field(
        ...,
        description="Whether the order was generated through `private/transfer_position`",
        title="is_transfer",
    )
    label: str = Field(
        ..., description="Optional user-defined label for the order", title="label"
    )
    last_update_timestamp: int = Field(
        ...,
        description="Last update timestamp (in ms since Unix epoch)",
        title="last_update_timestamp",
    )
    limit_price: Decimal = Field(
        ..., description="Limit price in quote currency", title="limit_price"
    )
    max_fee: Decimal = Field(
        ..., description="Max fee in units of the quote currency", title="max_fee"
    )
    mmp: bool = Field(
        ...,
        description="Whether the order is tagged for market maker protections",
        title="mmp",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_3_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    order_fee: Decimal = Field(
        ..., description="Total order fee paid so far", title="order_fee"
    )
    order_id: str = Field(..., description="Order ID", title="order_id")
    order_status: OrderStatus = Field(
        ..., description="Order status", title="order_status"
    )
    order_type: OrderType = Field(..., description="Order type", title="order_type")
    quote_id: Optional[UUID] = Field(
        ..., description="Quote ID if the trade was executed via RFQ", title="quote_id"
    )
    replaced_order_id: Optional[UUID] = Field(
        None,
        description="If replaced, ID of the order that was replaced",
        title="replaced_order_id",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the order", title="signature"
    )
    signature_expiry_sec: int = Field(
        ..., description="Signature expiry timestamp", title="signature_expiry_sec"
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed order",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    time_in_force: TimeInForce = Field(
        ..., description="Time in force", title="time_in_force"
    )
    trigger_price: Optional[Decimal] = Field(
        None,
        description="(Required for trigger orders) Index or Market price to trigger order at",
        title="trigger_price",
    )
    trigger_price_type: Optional[TriggerPriceType] = Field(
        None,
        description="(Required for trigger orders) Trigger with Index or Mark Price",
        title="trigger_price_type",
    )
    trigger_reject_message: Optional[str] = Field(
        None,
        description="(Required for trigger orders) Error message if error occured during trigger",
        title="trigger_reject_message",
    )
    trigger_type: Optional[TriggerType] = Field(
        None,
        description="(Required for trigger orders) Stop-loss or Take-profit.",
        title="trigger_type",
    )


class LiquidityRole(str, Enum):
    maker = "maker"
    taker = "taker"


class TxStatus(str, Enum):
    requested = "requested"
    pending = "pending"
    settled = "settled"
    reverted = "reverted"
    ignored = "ignored"
    timed_out = "timed_out"


class TradeResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    direction: Direction = Field(..., description="Order direction", title="direction")
    expected_rebate: Decimal = Field(
        ..., description="Expected rebate for this trade", title="expected_rebate"
    )
    index_price: Decimal = Field(
        ...,
        description="Index price of the underlying at the time of the trade",
        title="index_price",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    is_transfer: bool = Field(
        ...,
        description="Whether the trade was generated through `private/transfer_position`",
        title="is_transfer",
    )
    label: str = Field(
        ..., description="Optional user-defined label for the order", title="label"
    )
    liquidity_role: LiquidityRole = Field(
        ..., description="Role of the user in the trade", title="liquidity_role"
    )
    mark_price: Decimal = Field(
        ...,
        description="Mark price of the instrument at the time of the trade",
        title="mark_price",
    )
    order_id: str = Field(..., description="Order ID", title="order_id")
    quote_id: Optional[UUID] = Field(
        ..., description="Quote ID if the trade was executed via RFQ", title="quote_id"
    )
    realized_pnl: Decimal = Field(
        ..., description="Realized PnL for this trade", title="realized_pnl"
    )
    realized_pnl_excl_fees: Decimal = Field(
        ...,
        description="Realized PnL for this trade using cost accounting that excludes fees",
        title="realized_pnl_excl_fees",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    timestamp: int = Field(
        ..., description="Trade timestamp (in ms since Unix epoch)", title="timestamp"
    )
    trade_amount: Decimal = Field(
        ..., description="Amount filled in this trade", title="trade_amount"
    )
    trade_fee: Decimal = Field(..., description="Fee for this trade", title="trade_fee")
    trade_id: str = Field(..., description="Trade ID", title="trade_id")
    trade_price: Decimal = Field(
        ..., description="Price at which the trade was filled", title="trade_price"
    )
    transaction_id: str = Field(
        ...,
        description="The transaction id of the related settlement transaction",
        title="transaction_id",
    )
    tx_hash: Optional[str] = Field(
        ..., description="Blockchain transaction hash", title="tx_hash"
    )
    tx_status: TxStatus = Field(
        ..., description="Blockchain transaction status", title="tx_status"
    )


class PrivateCreateSubaccountParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount of the asset to deposit", title="amount"
    )
    asset_name: str = Field(
        ..., description="Name of asset to deposit", title="asset_name"
    )
    currency: Optional[str] = Field(
        None,
        description="Base currency of the subaccount (only for `PM`)",
        title="currency",
    )
    margin_type: MarginType = Field(
        ...,
        description="`PM` (Portfolio Margin), `PM2 (Portfolio Margin 2), or `SM` (Standard Margin))",
        title="margin_type",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the deposit", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be >5min from now",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Ethereum wallet address that is signing the deposit",
        title="signer",
    )
    wallet: str = Field(..., description="Ethereum wallet address", title="wallet")


class PrivateCreateSubaccountResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    status: str = Field(..., description="`requested`", title="status")
    transaction_id: UUID = Field(
        ..., description="Transaction id of the request", title="transaction_id"
    )


class LegUnpricedSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount in units of the base", title="amount"
    )
    direction: Direction = Field(..., description="Leg direction", title="direction")
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )


class CancelReason1(str, Enum):
    field_ = ""
    user_request = "user_request"
    insufficient_margin = "insufficient_margin"
    signed_max_fee_too_low = "signed_max_fee_too_low"
    mmp_trigger = "mmp_trigger"
    cancel_on_disconnect = "cancel_on_disconnect"
    session_key_deregistered = "session_key_deregistered"
    subaccount_withdrawn = "subaccount_withdrawn"
    rfq_no_longer_open = "rfq_no_longer_open"
    compliance = "compliance"


class Status1(str, Enum):
    open = "open"
    filled = "filled"
    cancelled = "cancelled"
    expired = "expired"


class PrivateSendRfqResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ask_total_cost: Optional[Decimal] = Field(
        ...,
        description="Ask total cost for the RFQ implied from orderbook (as `sell`)",
        title="ask_total_cost",
    )
    bid_total_cost: Optional[Decimal] = Field(
        ...,
        description="Bid total cost for the RFQ implied from orderbook (as `buy`)",
        title="bid_total_cost",
    )
    cancel_reason: CancelReason1 = Field(
        ..., description="Cancel reason, if any", title="cancel_reason"
    )
    counterparties: Optional[List[str]] = Field(
        ...,
        description="List of requested counterparties, if applicable",
        title="counterparties",
    )
    creation_timestamp: int = Field(
        ...,
        description="Creation timestamp in ms since Unix epoch",
        title="creation_timestamp",
    )
    filled_direction: Optional[Direction] = Field(
        ...,
        description="Direction at which the RFQ was filled (only if filled)",
        title="filled_direction",
    )
    filled_pct: Decimal = Field(
        ...,
        description="Percentage of the RFQ that has been filled, from 0 to 1.",
        title="filled_pct",
    )
    label: str = Field(..., description="User-defined label, if any", title="label")
    last_update_timestamp: int = Field(
        ...,
        description="Last update timestamp in ms since Unix epoch",
        title="last_update_timestamp",
    )
    legs: List[LegUnpricedSchema] = Field(..., description="RFQ legs", title="legs")
    mark_total_cost: Optional[Decimal] = Field(
        ...,
        description="Mark total cost for the RFQ (assuming `buy` direction)",
        title="mark_total_cost",
    )
    max_total_cost: Optional[Decimal] = Field(
        ..., description="Max total cost for the RFQ", title="max_total_cost"
    )
    min_total_cost: Optional[Decimal] = Field(
        ..., description="Min total cost for the RFQ", title="min_total_cost"
    )
    partial_fill_step: Decimal = Field(
        ...,
        description="Step size for partial fills (default: 1)",
        title="partial_fill_step",
    )
    rfq_id: UUID = Field(..., description="RFQ ID", title="rfq_id")
    status: Status1 = Field(..., description="Status", title="status")
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    total_cost: Optional[Decimal] = Field(
        ..., description="Total cost for the RFQ (only if filled)", title="total_cost"
    )
    valid_until: int = Field(
        ...,
        description="RFQ expiry timestamp in ms since Unix epoch",
        title="valid_until",
    )


class PublicMarginWatchParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    force_onchain: bool = Field(
        False,
        description="Force the fetching of on-chain balances, default False.",
        title="force_onchain",
    )
    subaccount_id: int = Field(
        ..., description="Subaccount ID to get margin for.", title="subaccount_id"
    )


class CollateralPublicResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Asset amount of given collateral", title="amount"
    )
    asset_name: str = Field(..., description="Asset name", title="asset_name")
    asset_type: InstrumentType = Field(
        ...,
        description="Type of asset collateral (currently always `erc20`)",
        title="asset_type",
    )
    initial_margin: Decimal = Field(
        ...,
        description="USD value of collateral that contributes to initial margin",
        title="initial_margin",
    )
    maintenance_margin: Decimal = Field(
        ...,
        description="USD value of collateral that contributes to maintenance margin",
        title="maintenance_margin",
    )
    mark_price: Decimal = Field(
        ..., description="Current mark price of the asset", title="mark_price"
    )
    mark_value: Decimal = Field(
        ...,
        description="USD value of the collateral (amount * mark price)",
        title="mark_value",
    )


class PositionPublicResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Position amount held by subaccount", title="amount"
    )
    delta: Decimal = Field(
        ...,
        description="Asset delta (w.r.t. forward price for options, `1.0` for perps)",
        title="delta",
    )
    gamma: Decimal = Field(
        ..., description="Asset gamma (zero for non-options)", title="gamma"
    )
    index_price: Decimal = Field(
        ...,
        description="Current index (oracle) price for position's currency",
        title="index_price",
    )
    initial_margin: Decimal = Field(
        ...,
        description="USD initial margin requirement for this position",
        title="initial_margin",
    )
    instrument_name: str = Field(
        ...,
        description="Instrument name (same as the base Asset name)",
        title="instrument_name",
    )
    instrument_type: InstrumentType = Field(
        ..., description="`erc20`, `option`, or `perp`", title="instrument_type"
    )
    liquidation_price: Optional[Decimal] = Field(
        ...,
        description="Index price at which position will be liquidated",
        title="liquidation_price",
    )
    maintenance_margin: Decimal = Field(
        ...,
        description="USD maintenance margin requirement for this position",
        title="maintenance_margin",
    )
    mark_price: Decimal = Field(
        ...,
        description="Current mark price for position's instrument",
        title="mark_price",
    )
    mark_value: Decimal = Field(
        ...,
        description="USD value of the position; this represents how much USD can be recieved by fully closing the position at the current oracle price",
        title="mark_value",
    )
    theta: Decimal = Field(
        ..., description="Asset theta (zero for non-options)", title="theta"
    )
    vega: Decimal = Field(
        ..., description="Asset vega (zero for non-options)", title="vega"
    )


class PublicStatisticsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: Optional[str] = Field(
        None, description="Currency for stats", title="currency"
    )
    end_time: Optional[int] = Field(
        None, description="End time for statistics in ms", title="end_time"
    )
    instrument_name: str = Field(
        ...,
        description="Instrument name or 'ALL', 'OPTION', 'PERP', 'SPOT'",
        title="instrument_name",
    )


class PublicStatisticsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    daily_fees: Decimal = Field(..., description="24h Fees", title="daily_fees")
    daily_notional_volume: Decimal = Field(
        ..., description="24h Notional volume", title="daily_notional_volume"
    )
    daily_premium_volume: Decimal = Field(
        ..., description="24h Premium volume", title="daily_premium_volume"
    )
    daily_trades: int = Field(..., description="24h Trades", title="daily_trades")
    open_interest: Decimal = Field(
        ..., description="Open interest", title="open_interest"
    )
    total_fees: Decimal = Field(..., description="Total fees", title="total_fees")
    total_notional_volume: Decimal = Field(
        ..., description="Total notional volume", title="total_notional_volume"
    )
    total_premium_volume: Decimal = Field(
        ..., description="Total premium volume", title="total_premium_volume"
    )
    total_trades: int = Field(..., description="Total trades", title="total_trades")


class PublicLoginParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    signature: str = Field(
        ...,
        description="Signature of the timestamp, signed with the wallet's private key or a session key",
        title="signature",
    )
    timestamp: str = Field(
        ...,
        description="Message that was signed, in the form of a timestamp in ms since Unix epoch",
        title="timestamp",
    )
    wallet: str = Field(
        ..., description="Public key (wallet) of the account", title="wallet"
    )


class PublicLoginResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[int] = Field(
        ...,
        description="List of subaccount IDs that have been authenticated",
        title="result",
    )


class PrivateCancelParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    instrument_name: str = Field(..., title="instrument_name")
    order_id: UUID = Field(default_factory=uuid.uuid4)
    subaccount_id: int = Field(..., title="subaccount_id")


PrivateCancelResultSchema = OrderResponseSchema


class LegPricedSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount in units of the base", title="amount"
    )
    direction: Direction = Field(..., description="Leg direction", title="direction")
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    price: Decimal = Field(..., description="Leg price", title="price")


class PrivateExecuteQuoteResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancel_reason: CancelReason1 = Field(
        ..., description="Cancel reason, if any", title="cancel_reason"
    )
    creation_timestamp: int = Field(
        ...,
        description="Creation timestamp in ms since Unix epoch",
        title="creation_timestamp",
    )
    direction: Direction = Field(..., description="Quote direction", title="direction")
    fee: Decimal = Field(
        ..., description="Fee paid for this quote (if executed)", title="fee"
    )
    fill_pct: Decimal = Field(
        ...,
        description="Percentage of the RFQ that this quote would fill, from 0 to 1.",
        title="fill_pct",
    )
    is_transfer: bool = Field(
        ...,
        description="Whether the order was generated through `private/transfer_position`",
        title="is_transfer",
    )
    label: str = Field(..., description="User-defined label, if any", title="label")
    last_update_timestamp: int = Field(
        ...,
        description="Last update timestamp in ms since Unix epoch",
        title="last_update_timestamp",
    )
    legs: List[LegPricedSchema] = Field(..., description="Quote legs", title="legs")
    legs_hash: str = Field(
        ...,
        description="Hash of the legs of the best quote to be signed by the taker.",
        title="legs_hash",
    )
    liquidity_role: LiquidityRole = Field(
        ..., description="Liquidity role", title="liquidity_role"
    )
    max_fee: Decimal = Field(..., description="Signed max fee", title="max_fee")
    mmp: bool = Field(
        ...,
        description="Whether the quote is tagged for market maker protections (default false)",
        title="mmp",
    )
    nonce: int = Field(..., description="Nonce", title="nonce")
    quote_id: UUID = Field(..., description="Quote ID", title="quote_id")
    rfq_filled_pct: Decimal = Field(
        ...,
        description="Total percentage of the RFQ that has already been filled after this execution, from 0 to 1.",
        title="rfq_filled_pct",
    )
    rfq_id: UUID = Field(..., description="RFQ ID", title="rfq_id")
    signature: str = Field(
        ..., description="Ethereum signature of the quote", title="signature"
    )
    signature_expiry_sec: int = Field(
        ..., description="Unix timestamp in seconds", title="signature_expiry_sec"
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed the quote",
        title="signer",
    )
    status: Status1 = Field(..., description="Status", title="status")
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    tx_hash: Optional[str] = Field(
        ...,
        description="Blockchain transaction hash (only for executed quotes)",
        title="tx_hash",
    )
    tx_status: Optional[TxStatus] = Field(
        ...,
        description="Blockchain transaction status (only for executed quotes)",
        title="tx_status",
    )


class Period(str, Enum):
    field_60 = 60
    field_300 = 300
    field_900 = 900
    field_1800 = 1800
    field_3600 = 3600
    field_14400 = 14400
    field_28800 = 28800
    field_86400 = 86400
    field_604800 = 604800


class PublicGetSpotFeedHistoryCandlesParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(..., description="Currency", title="currency")
    end_timestamp: int = Field(..., description="End timestamp", title="end_timestamp")
    period: Period = Field(..., description="Period", title="period")
    start_timestamp: int = Field(
        ..., description="Start timestamp", title="start_timestamp"
    )


class SpotFeedHistoryCandlesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    close_price: Decimal = Field(..., description="Close price", title="close_price")
    high_price: Decimal = Field(..., description="High price", title="high_price")
    low_price: Decimal = Field(..., description="Low price", title="low_price")
    open_price: Decimal = Field(..., description="Open price", title="open_price")
    price: Decimal = Field(..., description="Spot price", title="price")
    timestamp: int = Field(
        ...,
        description="Timestamp of when the spot price was recored into the database",
        title="timestamp",
    )
    timestamp_bucket: int = Field(
        ...,
        description="Timestamp bucket; this value is regularly spaced out with `period` seconds between data points, missing values are forward-filled from earlier data where possible, if no earlier data is available, values are back-filled from the first observed data point",
        title="timestamp_bucket",
    )


class PrivatePollRfqsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    from_timestamp: int = Field(
        0,
        description="Earliest `last_update_timestamp` to filter by (in ms since Unix epoch). If not provied, defaults to 0.",
        title="from_timestamp",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    rfq_id: Optional[UUID] = Field(
        None, description="RFQ ID filter, if applicable", title="rfq_id"
    )
    rfq_subaccount_id: Optional[int] = Field(
        None,
        description="Filter returned RFQs by rfq requestor subaccount",
        title="rfq_subaccount_id",
    )
    status: Optional[Status1] = Field(
        None, description="RFQ status filter, if applicable", title="status"
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount ID for auth purposes, returned data will be scoped to this subaccount.",
        title="subaccount_id",
    )
    to_timestamp: int = Field(
        18446744073709552000,
        description="Latest `last_update_timestamp` to filter by (in ms since Unix epoch). If not provied, defaults to returning all data up to current time.",
        title="to_timestamp",
    )


class RFQResultPublicSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancel_reason: CancelReason1 = Field(
        ..., description="Cancel reason, if any", title="cancel_reason"
    )
    creation_timestamp: int = Field(
        ...,
        description="Creation timestamp in ms since Unix epoch",
        title="creation_timestamp",
    )
    filled_direction: Optional[Direction] = Field(
        ...,
        description="Direction at which the RFQ was filled (only if filled)",
        title="filled_direction",
    )
    filled_pct: Decimal = Field(
        ...,
        description="Percentage of the RFQ that has been filled, from 0 to 1.",
        title="filled_pct",
    )
    last_update_timestamp: int = Field(
        ...,
        description="Last update timestamp in ms since Unix epoch",
        title="last_update_timestamp",
    )
    legs: List[LegUnpricedSchema] = Field(..., description="RFQ legs", title="legs")
    partial_fill_step: Decimal = Field(
        ...,
        description="Step size for partial fills (default: 1)",
        title="partial_fill_step",
    )
    rfq_id: UUID = Field(..., description="RFQ ID", title="rfq_id")
    status: Status1 = Field(..., description="Status", title="status")
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    total_cost: Optional[Decimal] = Field(
        ..., description="Total cost for the RFQ (only if filled)", title="total_cost"
    )
    valid_until: int = Field(
        ...,
        description="RFQ expiry timestamp in ms since Unix epoch",
        title="valid_until",
    )


class PrivateGetLiquidationHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_timestamp: int = Field(
        9223372036854776000,
        description="End timestamp of the event history (default current time)",
        title="end_timestamp",
    )
    start_timestamp: int = Field(
        0,
        description="Start timestamp of the event history (default 0)",
        title="start_timestamp",
    )
    subaccount_id: int = Field(..., description="Subaccount id", title="subaccount_id")


class AuctionType(str, Enum):
    solvent = "solvent"
    insolvent = "insolvent"


class AuctionBidEventSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amounts_liquidated: Dict[str, Decimal] = Field(
        ...,
        description="Amounts of each asset that were closed",
        title="amounts_liquidated",
    )
    cash_received: Decimal = Field(
        ...,
        description="Cash received by the subaccount for the liquidation. For the liquidated accounts this is the amount the liquidator paid to buy out the percentage of the portfolio. For the liquidator account, this is the amount they received from the security module (if positive) or the amount they paid for the bid (if negative)",
        title="cash_received",
    )
    discount_pnl: Decimal = Field(
        ...,
        description="Realized PnL due to liquidating or being liquidated at a discount to mark portfolio value",
        title="discount_pnl",
    )
    percent_liquidated: Decimal = Field(
        ...,
        description="Percent of the subaccount that was liquidated",
        title="percent_liquidated",
    )
    positions_realized_pnl: Dict[str, Decimal] = Field(
        ...,
        description="Realized PnL of each position that was closed",
        title="positions_realized_pnl",
    )
    positions_realized_pnl_excl_fees: Dict[str, Decimal] = Field(
        ...,
        description="Realized PnL of each position that was closed, excluding fees from total cost basis",
        title="positions_realized_pnl_excl_fees",
    )
    realized_pnl: Decimal = Field(
        ...,
        description="Realized PnL of the auction bid, assuming positions are closed at mark price at the time of the liquidation",
        title="realized_pnl",
    )
    realized_pnl_excl_fees: Decimal = Field(
        ...,
        description="Realized PnL of the auction bid, excluding fees from total cost basis, assuming positions are closed at mark price at the time of the liquidation",
        title="realized_pnl_excl_fees",
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of the bid (in ms since UNIX epoch)",
        title="timestamp",
    )
    tx_hash: str = Field(
        ..., description="Hash of the bid transaction", title="tx_hash"
    )


class PrivateOrderDebugParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Order amount in units of the base", title="amount"
    )
    direction: Direction = Field(..., description="Order direction", title="direction")
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    is_atomic_signing: Optional[bool] = Field(
        False,
        description="Used by vaults to determine whether the signature is an EIP-1271 signature.",
        title="is_atomic_signing",
    )
    label: str = Field(
        "", description="Optional user-defined label for the order", title="label"
    )
    limit_price: Decimal = Field(
        ...,
        description="Limit price in quote currency.<br />This field is still required for market orders because it is a component of the signature. However, market orders will not leave a resting order in the book in case of a partial fill.",
        title="limit_price",
    )
    max_fee: Decimal = Field(
        ...,
        description="Max fee per unit of volume, denominated in units of the quote currency (usually USDC).Order will be rejected if the supplied max fee is below the estimated fee for this order.",
        title="max_fee",
    )
    mmp: bool = Field(
        False,
        description="Whether the order is tagged for market maker protections (default false)",
        title="mmp",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_3_digits> (e.g. 1695836058725001, where 001 is the random number).Note, using a random number beyond 3 digits will cause JSON serialization to fail.",
        title="nonce",
    )
    order_type: OrderType = Field(
        "limit",
        description="Order type:<br />- `limit`: limit order (default)<br />- `market`: market order, note that limit_price is still required for market orders, but unfilled order portion will be marked as cancelled",
        title="order_type",
    )
    reduce_only: bool = Field(
        False,
        description="If true, the order will not be able to increase position's size (default false). If the order amount exceeds available position size, the order will be filled up to the position size and the remainder will be cancelled. This flag is only supported for market orders or non-resting limit orders (IOC or FOK)",
        title="reduce_only",
    )
    referral_code: str = Field(
        "", description="Optional referral code for the order", title="referral_code"
    )
    reject_timestamp: int = Field(
        9223372036854776000,
        description="UTC timestamp in ms, if provided the matching engine will reject the order with an error if `reject_timestamp` < `server_time`. Note that the timestamp must be consistent with the server time: use `public/get_time` method to obtain current server time.",
        title="reject_timestamp",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the order", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Order signature becomes invalid after this time, and the system will cancel the order.Expiry MUST be at least 5 min from now.",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed order",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    time_in_force: TimeInForce = Field(
        "gtc",
        description="Time in force behaviour:<br />- `gtc`: good til cancelled (default)<br />- `post_only`: a limit order that will be rejected if it crosses any order in the book, i.e. acts as a taker order<br />- `fok`: fill or kill, will be rejected if it is not fully filled<br />- `ioc`: immediate or cancel, fill at best bid/ask (market) or at limit price (limit), the unfilled portion is cancelled<br />Note that the order will still expire on the `signature_expiry_sec` timestamp.",
        title="time_in_force",
    )
    trigger_price: Optional[Decimal] = Field(
        None,
        description='(Required for trigger orders) "index" or "mark" price to trigger order at',
        title="trigger_price",
    )
    trigger_price_type: Optional[TriggerPriceType] = Field(
        None,
        description='(Required for trigger orders) Trigger with "mark" price as "index" price type not supported yet.',
        title="trigger_price_type",
    )
    trigger_type: Optional[TriggerType] = Field(
        None,
        description='(Required for trigger orders) "stoploss" or "takeprofit"',
        title="trigger_type",
    )


class TradeModuleDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    asset: str = Field(..., title="asset")
    desired_amount: Decimal = Field(..., title="desired_amount")
    is_bid: bool = Field(..., title="is_bid")
    limit_price: Decimal = Field(..., title="limit_price")
    recipient_id: int = Field(..., title="recipient_id")
    sub_id: int = Field(..., title="sub_id")
    trade_id: str = Field(..., title="trade_id")
    worst_fee: Decimal = Field(..., title="worst_fee")


class PrivateDepositParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount of the asset to deposit", title="amount"
    )
    asset_name: str = Field(
        ..., description="Name of asset to deposit", title="asset_name"
    )
    is_atomic_signing: bool = Field(
        False,
        description="Used by vaults to determine whether the signature is an EIP-1271 signature",
        title="is_atomic_signing",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the deposit", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be >5min from now",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Ethereum wallet address that is signing the deposit",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class PrivateDepositResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    status: str = Field(..., description="`requested`", title="status")
    transaction_id: UUID = Field(
        ..., description="Transaction id of the deposit", title="transaction_id"
    )


class PrivateUpdateNotificationsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    notification_ids: List[int] = Field(
        ...,
        description="List of notification IDs to be marked as seen",
        title="notification_ids",
    )
    status: Status = Field(
        "seen", description="Status of the notification", title="status"
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class PrivateUpdateNotificationsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    updated_count: int = Field(
        ..., description="Number of notifications marked as seen", title="updated_count"
    )


class PrivateChangeSubaccountLabelParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    label: str = Field(..., description="User defined label", title="label")
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


PrivateChangeSubaccountLabelResultSchema = PrivateChangeSubaccountLabelParamsSchema


class SignedQuoteParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    direction: Direction = Field(
        ...,
        description="Quote direction, `buy` means trading each leg at its direction, `sell` means trading each leg in the opposite direction.",
        title="direction",
    )
    legs: List[LegPricedSchema] = Field(..., description="Quote legs", title="legs")
    max_fee: Decimal = Field(
        ...,
        description="Max fee ($ for the full trade). Request will be rejected if the supplied max fee is below the estimated fee for this trade.",
        title="max_fee",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as a concatenated `UTC timestamp in ms` and `random number up to 6 digits` (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the quote", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be at least 310 seconds from now. Once time till signature expiry reaches 300 seconds, the quote will be considered expired. This buffer is meant to ensure the trade can settle on chain in case of a blockchain congestion.",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed the quote",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class QuoteResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancel_reason: CancelReason1 = Field(
        ..., description="Cancel reason, if any", title="cancel_reason"
    )
    creation_timestamp: int = Field(
        ...,
        description="Creation timestamp in ms since Unix epoch",
        title="creation_timestamp",
    )
    direction: Direction = Field(..., description="Quote direction", title="direction")
    fee: Decimal = Field(
        ..., description="Fee paid for this quote (if executed)", title="fee"
    )
    fill_pct: Decimal = Field(
        ...,
        description="Percentage of the RFQ that this quote would fill, from 0 to 1.",
        title="fill_pct",
    )
    is_transfer: bool = Field(
        ...,
        description="Whether the order was generated through `private/transfer_position`",
        title="is_transfer",
    )
    label: str = Field(..., description="User-defined label, if any", title="label")
    last_update_timestamp: int = Field(
        ...,
        description="Last update timestamp in ms since Unix epoch",
        title="last_update_timestamp",
    )
    legs: List[LegPricedSchema] = Field(..., description="Quote legs", title="legs")
    legs_hash: str = Field(
        ...,
        description="Hash of the legs of the best quote to be signed by the taker.",
        title="legs_hash",
    )
    liquidity_role: LiquidityRole = Field(
        ..., description="Liquidity role", title="liquidity_role"
    )
    max_fee: Decimal = Field(..., description="Signed max fee", title="max_fee")
    mmp: bool = Field(
        ...,
        description="Whether the quote is tagged for market maker protections (default false)",
        title="mmp",
    )
    nonce: int = Field(..., description="Nonce", title="nonce")
    quote_id: UUID = Field(..., description="Quote ID", title="quote_id")
    rfq_id: UUID = Field(..., description="RFQ ID", title="rfq_id")
    signature: str = Field(
        ..., description="Ethereum signature of the quote", title="signature"
    )
    signature_expiry_sec: int = Field(
        ..., description="Unix timestamp in seconds", title="signature_expiry_sec"
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed the quote",
        title="signer",
    )
    status: Status1 = Field(..., description="Status", title="status")
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    tx_hash: Optional[str] = Field(
        ...,
        description="Blockchain transaction hash (only for executed quotes)",
        title="tx_hash",
    )
    tx_status: Optional[TxStatus] = Field(
        ...,
        description="Blockchain transaction status (only for executed quotes)",
        title="tx_status",
    )


class PublicGetMakerProgramsParamsSchema(BaseModel):
    pass
    model_config = ConfigDict(
        extra="forbid",
    )


class ProgramResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    asset_types: List[str] = Field(
        ...,
        description="List of asset types covered by the program",
        title="asset_types",
    )
    currencies: List[str] = Field(
        ..., description="List of currencies covered by the program", title="currencies"
    )
    end_timestamp: int = Field(
        ..., description="End timestamp of the epoch", title="end_timestamp"
    )
    min_notional: Decimal = Field(
        ...,
        description="Minimum dollar notional to quote for eligibility",
        title="min_notional",
    )
    name: str = Field(..., description="Name of the program", title="name")
    rewards: Dict[str, Decimal] = Field(
        ...,
        description="Rewards for the program as a token -> total reward amount mapping",
        title="rewards",
    )
    start_timestamp: int = Field(
        ..., description="Start timestamp of the epoch", title="start_timestamp"
    )


class SimulatedCollateralSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Collateral amount to simulate", title="amount"
    )
    asset_name: str = Field(
        ...,
        description="Collateral ERC20 asset name (e.g. ETH, USDC, WSTETH)",
        title="asset_name",
    )


class SimulatedPositionSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Position amount to simulate", title="amount"
    )
    entry_price: Optional[Decimal] = Field(
        None,
        description="Only for perps. Entry price to use in the simulation. Mark price is used if not provided.",
        title="entry_price",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )


class PublicGetMarginResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    is_valid_trade: bool = Field(
        ...,
        description="True if trade passes margin requirement",
        title="is_valid_trade",
    )
    post_initial_margin: Decimal = Field(
        ...,
        description="Initial margin requirement post trade",
        title="post_initial_margin",
    )
    post_maintenance_margin: Decimal = Field(
        ...,
        description="Maintenance margin requirement post trade",
        title="post_maintenance_margin",
    )
    pre_initial_margin: Decimal = Field(
        ...,
        description="Initial margin requirement before trade",
        title="pre_initial_margin",
    )
    pre_maintenance_margin: Decimal = Field(
        ...,
        description="Maintenance margin requirement before trade",
        title="pre_maintenance_margin",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class PrivateCancelByNonceParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    nonce: int = Field(
        ..., description="Cancel an order with this nonce", title="nonce"
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    wallet: str = Field(..., description="Wallet address", title="wallet")


class PrivateCancelByNonceResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancelled_orders: int = Field(
        ..., description="Number of cancelled orders", title="cancelled_orders"
    )


class PublicGetSpotFeedHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(..., description="Currency", title="currency")
    end_timestamp: int = Field(..., description="End timestamp", title="end_timestamp")
    period: int = Field(..., description="Period", title="period")
    start_timestamp: int = Field(
        ..., description="Start timestamp", title="start_timestamp"
    )


class SpotFeedHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    price: Decimal = Field(..., description="Spot price", title="price")
    timestamp: int = Field(
        ...,
        description="Timestamp of when the spot price was recored into the database",
        title="timestamp",
    )
    timestamp_bucket: int = Field(
        ...,
        description="Timestamp bucket; this value is regularly spaced out with `period` seconds between data points, missing values are forward-filled from earlier data where possible, if no earlier data is available, values are back-filled from the first observed data point",
        title="timestamp_bucket",
    )


class PrivateGetSubaccountsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    wallet: str = Field(
        ..., description="Ethereum wallet address of account", title="wallet"
    )


class PrivateGetSubaccountsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subaccount_ids: List[int] = Field(
        ...,
        description="List of subaccount_ids owned by the wallet in `SubAccounts.sol`",
        title="subaccount_ids",
    )
    wallet: str = Field(..., description="Ethereum wallet address", title="wallet")


PrivateGetDepositHistoryParamsSchema = PrivateGetLiquidationHistoryParamsSchema


class DepositSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount deposited by the subaccount", title="amount"
    )
    asset: str = Field(..., description="Asset deposited", title="asset")
    error_log: Optional[Dict[str, Any]] = Field(
        ..., description="If failed, error log for reason", title="error_log"
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of the deposit (in ms since UNIX epoch)",
        title="timestamp",
    )
    transaction_id: UUID = Field(
        ..., description="Transaction ID", title="transaction_id"
    )
    tx_hash: str = Field(
        ...,
        description="Hash of the transaction that deposited the funds",
        title="tx_hash",
    )
    tx_status: TxStatus = Field(
        ...,
        description="Status of the transaction that deposited the funds",
        title="tx_status",
    )


class PrivateCancelByLabelParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    instrument_name: Optional[str] = Field(
        None,
        description="Instrument name. If not provided, all orders for all instruments with the label will be cancelled.  If provided, request counts as a regular matching request for ratelimit purposes.",
        title="instrument_name",
    )
    label: str = Field(
        ..., description="Cancel all orders for this label", title="label"
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


PrivateCancelByLabelResultSchema = PrivateCancelByNonceResultSchema


class PrivateGetMarginParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    simulated_collateral_changes: Optional[List[SimulatedCollateralSchema]] = Field(
        None,
        description="Optional, add collaterals to simulate deposits / withdrawals / spot trades",
        title="simulated_collateral_changes",
    )
    simulated_position_changes: Optional[List[SimulatedPositionSchema]] = Field(
        None,
        description="Optional, add positions to simulate perp / option trades",
        title="simulated_position_changes",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


PrivateGetMarginResultSchema = PublicGetMarginResultSchema


class PublicCreateSubaccountDebugParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount of the asset to deposit", title="amount"
    )
    asset_name: str = Field(
        ..., description="Name of asset to deposit", title="asset_name"
    )
    currency: Optional[str] = Field(
        None,
        description="Base currency of the subaccount (only for `PM`)",
        title="currency",
    )
    margin_type: MarginType = Field(
        ...,
        description="`PM` (Portfolio Margin), `PM2 (Portfolio Margin 2), or `SM` (Standard Margin))",
        title="margin_type",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be >5min from now",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Ethereum wallet address that is signing the deposit",
        title="signer",
    )
    wallet: str = Field(..., description="Ethereum wallet address", title="wallet")


class PublicCreateSubaccountDebugResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    action_hash: str = Field(
        ..., description="Keccak hashed action data", title="action_hash"
    )
    encoded_data: str = Field(
        ..., description="ABI encoded deposit data", title="encoded_data"
    )
    encoded_data_hashed: str = Field(
        ..., description="Keccak hashed encoded_data", title="encoded_data_hashed"
    )
    typed_data_hash: str = Field(
        ..., description="EIP 712 typed data hash", title="typed_data_hash"
    )


class PublicGetInstrumentParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )


class ERC20PublicDetailsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    borrow_index: Decimal = Field(
        "1",
        description="Latest borrow index as per `CashAsset.sol` implementation",
        title="borrow_index",
    )
    decimals: int = Field(
        ...,
        description="Number of decimals of the underlying on-chain ERC20 token",
        title="decimals",
    )
    supply_index: Decimal = Field(
        "1",
        description="Latest supply index as per `CashAsset.sol` implementation",
        title="supply_index",
    )
    underlying_erc20_address: str = Field(
        "",
        description="Address of underlying on-chain ERC20 (not V2 asset)",
        title="underlying_erc20_address",
    )


class OptionType(str, Enum):
    C = "C"
    P = "P"


class OptionPublicDetailsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry: int = Field(
        ..., description="Unix timestamp of expiry date (in seconds)", title="expiry"
    )
    index: str = Field(
        ..., description="Underlying settlement price index", title="index"
    )
    option_type: OptionType = Field(..., title="option_type")
    settlement_price: Optional[Decimal] = Field(
        None, description="Settlement price of the option", title="settlement_price"
    )
    strike: Decimal = Field(..., title="strike")


class PerpPublicDetailsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    aggregate_funding: Decimal = Field(
        ...,
        description="Latest aggregated funding as per `PerpAsset.sol`",
        title="aggregate_funding",
    )
    funding_rate: Decimal = Field(
        ...,
        description="Current hourly funding rate as per `PerpAsset.sol`",
        title="funding_rate",
    )
    index: str = Field(
        ..., description="Underlying spot price index for funding rate", title="index"
    )
    max_rate_per_hour: Decimal = Field(
        ...,
        description="Max rate per hour as per `PerpAsset.sol`",
        title="max_rate_per_hour",
    )
    min_rate_per_hour: Decimal = Field(
        ...,
        description="Min rate per hour as per `PerpAsset.sol`",
        title="min_rate_per_hour",
    )
    static_interest_rate: Decimal = Field(
        ...,
        description="Static interest rate as per `PerpAsset.sol`",
        title="static_interest_rate",
    )


class PrivateEditSessionKeyParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    disable: bool = Field(
        False,
        description="Flag whether or not to disable to session key. Defaulted to false. Only allowed for non-admin keys. Admin keys must go through `/deregister_session_key` for now.",
        title="disable",
    )
    ip_whitelist: Optional[List[str]] = Field(
        None,
        description="Optional list of whitelisted IPs, an empty list can be supplied to whitelist all IPs",
        title="ip_whitelist",
    )
    label: Optional[str] = Field(
        None, description="Optional new label for the session key", title="label"
    )
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    wallet: str = Field(
        ..., description="Ethereum wallet address of account", title="wallet"
    )


class PrivateEditSessionKeyResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_sec: int = Field(
        ..., description="Session key expiry timestamp in sec", title="expiry_sec"
    )
    ip_whitelist: List[str] = Field(
        ...,
        description="List of whitelisted IPs, if empty then any IP is allowed.",
        title="ip_whitelist",
    )
    label: str = Field(..., description="User-defined session key label", title="label")
    public_session_key: str = Field(
        ...,
        description="Public session key address (Ethereum EOA)",
        title="public_session_key",
    )
    scope: str = Field(
        ..., description="Session key permission level scope", title="scope"
    )


class PrivateGetLiquidatorHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_timestamp: int = Field(
        9223372036854776000,
        description="End timestamp of the event history (default current time)",
        title="end_timestamp",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    start_timestamp: int = Field(
        0,
        description="Start timestamp of the event history (default 0)",
        title="start_timestamp",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class PrivateGetLiquidatorHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    bids: List[AuctionBidEventSchema] = Field(
        ..., description="List of auction bid events", title="bids"
    )
    pagination: PaginationInfoSchema


class PrivateGetPositionsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class PositionResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Position amount held by subaccount", title="amount"
    )
    amount_step: Decimal = Field(
        ..., description="Minimum amount step for the position", title="amount_step"
    )
    average_price: Decimal = Field(
        ..., description="Average price of whole position", title="average_price"
    )
    average_price_excl_fees: Decimal = Field(
        ...,
        description="Average price of whole position excluding fees",
        title="average_price_excl_fees",
    )
    creation_timestamp: int = Field(
        ...,
        description="Timestamp of when the position was opened (in ms since Unix epoch)",
        title="creation_timestamp",
    )
    cumulative_funding: Decimal = Field(
        ...,
        description="Cumulative funding for the position (only for perpetuals).",
        title="cumulative_funding",
    )
    delta: Decimal = Field(
        ...,
        description="Asset delta (w.r.t. forward price for options, `1.0` for perps)",
        title="delta",
    )
    gamma: Decimal = Field(
        ..., description="Asset gamma (zero for non-options)", title="gamma"
    )
    index_price: Decimal = Field(
        ...,
        description="Current index (oracle) price for position's currency",
        title="index_price",
    )
    initial_margin: Decimal = Field(
        ...,
        description="USD initial margin requirement for this position",
        title="initial_margin",
    )
    instrument_name: str = Field(
        ...,
        description="Instrument name (same as the base Asset name)",
        title="instrument_name",
    )
    instrument_type: InstrumentType = Field(
        ..., description="`erc20`, `option`, or `perp`", title="instrument_type"
    )
    leverage: Optional[Decimal] = Field(
        ...,
        description="Only for perps. Leverage of the position, defined as `abs(notional) / collateral net of options margin`",
        title="leverage",
    )
    liquidation_price: Optional[Decimal] = Field(
        ...,
        description="Index price at which position will be liquidated",
        title="liquidation_price",
    )
    maintenance_margin: Decimal = Field(
        ...,
        description="USD maintenance margin requirement for this position",
        title="maintenance_margin",
    )
    mark_price: Decimal = Field(
        ...,
        description="Current mark price for position's instrument",
        title="mark_price",
    )
    mark_value: Decimal = Field(
        ...,
        description="USD value of the position; this represents how much USD can be recieved by fully closing the position at the current oracle price",
        title="mark_value",
    )
    net_settlements: Decimal = Field(
        ...,
        description="Net amount of USD from position settlements that has been paid to the user's subaccount. This number is subtracted from the portfolio value for margin calculations purposes.<br />Positive values mean the user has recieved USD from settlements, or is awaiting settlement of USD losses. Negative values mean the user has paid USD for settlements, or is awaiting settlement of USD gains.",
        title="net_settlements",
    )
    open_orders_margin: Decimal = Field(
        ...,
        description="USD margin requirement for all open orders for this asset / instrument",
        title="open_orders_margin",
    )
    pending_funding: Decimal = Field(
        ...,
        description="A portion of funding payments that has not yet been settled into cash balance (only for perpetuals). This number is added to the portfolio value for margin calculations purposes.",
        title="pending_funding",
    )
    realized_pnl: Decimal = Field(
        ...,
        description="Realized trading profit or loss of the position.",
        title="realized_pnl",
    )
    realized_pnl_excl_fees: Decimal = Field(
        ...,
        description="Realized trading profit or loss of the position excluding fees",
        title="realized_pnl_excl_fees",
    )
    theta: Decimal = Field(
        ..., description="Asset theta (zero for non-options)", title="theta"
    )
    total_fees: Decimal = Field(
        ...,
        description="Total fees paid for opening and changing the position",
        title="total_fees",
    )
    unrealized_pnl: Decimal = Field(
        ...,
        description="Unrealized trading profit or loss of the position.",
        title="unrealized_pnl",
    )
    unrealized_pnl_excl_fees: Decimal = Field(
        ...,
        description="Unrealized trading profit or loss of the position excluding fees",
        title="unrealized_pnl_excl_fees",
    )
    vega: Decimal = Field(
        ..., description="Asset vega (zero for non-options)", title="vega"
    )


class TxStatus4(str, Enum):
    settled = "settled"
    reverted = "reverted"
    timed_out = "timed_out"


class PublicGetTradeHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: Optional[str] = Field(
        None, description="Currency to filter by (defaults to all)", title="currency"
    )
    from_timestamp: int = Field(
        0,
        description="Earliest timestamp to filter by (in ms since Unix epoch). If not provied, defaults to 0.",
        title="from_timestamp",
    )
    instrument_name: Optional[str] = Field(
        None,
        description="Instrument name to filter by (defaults to all)",
        title="instrument_name",
    )
    instrument_type: Optional[InstrumentType] = Field(
        None,
        description="Instrument type to filter by (defaults to all)",
        title="instrument_type",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    subaccount_id: Optional[int] = Field(
        None, description="Subaccount ID to filter by", title="subaccount_id"
    )
    to_timestamp: int = Field(
        18446744073709552000,
        description="Latest timestamp to filter by (in ms since Unix epoch). If not provied, defaults to returning all data up to current time.",
        title="to_timestamp",
    )
    trade_id: Optional[UUID] = Field(
        None,
        description="Trade ID to filter by. If set, all other filters are ignored",
        title="trade_id",
    )
    tx_hash: Optional[str] = Field(
        None,
        description="On-chain tx hash to filter by. If set, all other filters are ignored",
        title="tx_hash",
    )
    tx_status: TxStatus4 = Field(
        "settled",
        description="Transaction status to filter by (default `settled`).",
        title="tx_status",
    )


class TradeSettledPublicResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    direction: Direction = Field(..., description="Order direction", title="direction")
    expected_rebate: Decimal = Field(
        ..., description="Expected rebate for this trade", title="expected_rebate"
    )
    index_price: Decimal = Field(
        ...,
        description="Index price of the underlying at the time of the trade",
        title="index_price",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    liquidity_role: LiquidityRole = Field(
        ..., description="Role of the user in the trade", title="liquidity_role"
    )
    mark_price: Decimal = Field(
        ...,
        description="Mark price of the instrument at the time of the trade",
        title="mark_price",
    )
    quote_id: Optional[UUID] = Field(
        ..., description="Quote ID if the trade was executed via RFQ", title="quote_id"
    )
    realized_pnl: Decimal = Field(
        ..., description="Realized PnL for this trade", title="realized_pnl"
    )
    realized_pnl_excl_fees: Decimal = Field(
        ...,
        description="Realized PnL for this trade using cost accounting that excludes fees",
        title="realized_pnl_excl_fees",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    timestamp: int = Field(
        ..., description="Trade timestamp (in ms since Unix epoch)", title="timestamp"
    )
    trade_amount: Decimal = Field(
        ..., description="Amount filled in this trade", title="trade_amount"
    )
    trade_fee: Decimal = Field(..., description="Fee for this trade", title="trade_fee")
    trade_id: str = Field(..., description="Trade ID", title="trade_id")
    trade_price: Decimal = Field(
        ..., description="Price at which the trade was filled", title="trade_price"
    )
    tx_hash: str = Field(
        ..., description="Blockchain transaction hash", title="tx_hash"
    )
    tx_status: TxStatus4 = Field(
        ..., description="Blockchain transaction status", title="tx_status"
    )
    wallet: str = Field(
        ..., description="Wallet address (owner) of the subaccount", title="wallet"
    )


class PrivateGetRfqsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    from_timestamp: int = Field(
        0,
        description="Earliest `last_update_timestamp` to filter by (in ms since Unix epoch). If not provied, defaults to 0.",
        title="from_timestamp",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    rfq_id: Optional[UUID] = Field(
        None, description="RFQ ID filter, if applicable", title="rfq_id"
    )
    status: Optional[Status1] = Field(
        None, description="RFQ status filter, if applicable", title="status"
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount ID for auth purposes, returned data will be scoped to this subaccount.",
        title="subaccount_id",
    )
    to_timestamp: int = Field(
        18446744073709552000,
        description="Latest `last_update_timestamp` to filter by (in ms since Unix epoch). If not provied, defaults to returning all data up to current time.",
        title="to_timestamp",
    )


RFQResultSchema = PrivateSendRfqResultSchema


class SignatureDetailsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the transfer", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be >5min from now",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Ethereum wallet address that is signing the transfer",
        title="signer",
    )


class TransferDetailsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    address: str = Field(
        ...,
        description="Ethereum address of the asset being transferred",
        title="address",
    )
    amount: Decimal = Field(..., description="Amount to transfer", title="amount")
    sub_id: int = Field(
        ..., description="Sub ID of the asset being transferred", title="sub_id"
    )


class PrivateTransferErc20ResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    status: str = Field(..., description="`requested`", title="status")
    transaction_id: UUID = Field(
        ..., description="Transaction id of the transfer", title="transaction_id"
    )


class PrivateSendQuoteParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    direction: Direction = Field(
        ...,
        description="Quote direction, `buy` means trading each leg at its direction, `sell` means trading each leg in the opposite direction.",
        title="direction",
    )
    label: str = Field(
        "", description="Optional user-defined label for the quote", title="label"
    )
    legs: List[LegPricedSchema] = Field(..., description="Quote legs", title="legs")
    max_fee: Decimal = Field(
        ...,
        description="Max fee ($ for the full trade). Request will be rejected if the supplied max fee is below the estimated fee for this trade.",
        title="max_fee",
    )
    mmp: bool = Field(
        False,
        description="Whether the quote is tagged for market maker protections (default false)",
        title="mmp",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as a concatenated `UTC timestamp in ms` and `random number up to 6 digits` (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    rfq_id: UUID = Field(default_factory=uuid.uuid4)
    signature: str = Field(
        ..., description="Ethereum signature of the quote", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be at least 310 seconds from now. Once time till signature expiry reaches 300 seconds, the quote will be considered expired. This buffer is meant to ensure the trade can settle on chain in case of a blockchain congestion.",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed the quote",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


PrivateSendQuoteResultSchema = QuoteResultSchema


class PrivateCancelTriggerOrderParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    order_id: UUID = Field(default_factory=uuid.uuid4)
    subaccount_id: int = Field(..., title="subaccount_id")


PrivateCancelTriggerOrderResultSchema = OrderResponseSchema


PrivateGetWithdrawalHistoryParamsSchema = PrivateGetLiquidationHistoryParamsSchema


class WithdrawalSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount withdrawn by the subaccount", title="amount"
    )
    asset: str = Field(..., description="Asset withdrawn", title="asset")
    error_log: Optional[Dict[str, Any]] = Field(
        ..., description="If failed, error log for reason", title="error_log"
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of the withdrawal (in ms since UNIX epoch)",
        title="timestamp",
    )
    tx_hash: str = Field(
        ...,
        description="Hash of the transaction that withdrew the funds",
        title="tx_hash",
    )
    tx_status: TxStatus = Field(
        ...,
        description="Status of the transaction that deposited the funds",
        title="tx_status",
    )


class PublicGetOptionSettlementPricesParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(
        ..., description="Currency for which to show expiries", title="currency"
    )


class ExpiryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_date: str = Field(
        ..., description="Expiry date in `YYYYMMDD` format", title="expiry_date"
    )
    price: Optional[Decimal] = Field(
        ...,
        description="Settlement price will show None if not yet settled onchain",
        title="price",
    )
    utc_expiry_sec: int = Field(
        ..., description="UTC timestamp of expiry", title="utc_expiry_sec"
    )


class PublicGetMakerProgramScoresParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    epoch_start_timestamp: int = Field(
        ...,
        description="Start timestamp of the program epoch",
        title="epoch_start_timestamp",
    )
    program_name: str = Field(..., description="Program name", title="program_name")


class ScoreBreakdownSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    coverage_score: Decimal = Field(
        ...,
        description="Coverag component of the score of the account for this program",
        title="coverage_score",
    )
    holder_boost: Decimal = Field(
        ...,
        description="A custom account multiplier for the score due to holding tokens",
        title="holder_boost",
    )
    quality_score: Decimal = Field(
        ...,
        description="Quality component of the score of the account for this program",
        title="quality_score",
    )
    total_score: Decimal = Field(
        ...,
        description="Total score of the account for this program",
        title="total_score",
    )
    volume: Decimal = Field(
        ..., description="Volume traded by the account for this epoch", title="volume"
    )
    volume_multiplier: Decimal = Field(
        ...,
        description="Multiplier for the volume traded by the account",
        title="volume_multiplier",
    )
    wallet: str = Field(
        ..., description="Wallet address of the account", title="wallet"
    )


class PublicBuildRegisterSessionKeyTxParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_sec: int = Field(
        ..., description="Expiry of the session key", title="expiry_sec"
    )
    gas: Optional[int] = Field(
        ...,
        description="Gas allowance for transaction. If none, will use estimateGas * 150%",
        title="gas",
    )
    nonce: Optional[int] = Field(
        ...,
        description="Wallet's transaction count, If none, will use eth.getTransactionCount()",
        title="nonce",
    )
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    wallet: str = Field(
        ..., description="Ethereum wallet address of account", title="wallet"
    )


class PublicBuildRegisterSessionKeyTxResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    tx_params: Dict[str, Any] = Field(
        ...,
        description="Transaction params in dictionary form, same as `TxParams` in `web3.py`",
        title="tx_params",
    )


class PublicRegisterSessionKeyParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_sec: int = Field(
        ..., description="Expiry of the session key", title="expiry_sec"
    )
    label: str = Field(..., description="Ethereum wallet address", title="label")
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    signed_raw_tx: str = Field(
        ...,
        description="A signed RLP encoded ETH transaction in form of a hex string (same as `w3.eth.account.sign_transaction(unsigned_tx, private_key).rawTransaction.hex()`)",
        title="signed_raw_tx",
    )
    wallet: str = Field(
        ..., description="Ethereum wallet address of account", title="wallet"
    )


class PublicRegisterSessionKeyResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    label: str = Field(..., description="User-defined session key label", title="label")
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    transaction_id: UUID = Field(
        ..., description="ID to lookup status of transaction", title="transaction_id"
    )


class PrivateGetOrderHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to get order history",
        title="subaccount_id",
    )


class PrivateGetOrderHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    orders: List[OrderResponseSchema] = Field(
        ..., description="List of open orders", title="orders"
    )
    pagination: PaginationInfoSchema
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to get open orders",
        title="subaccount_id",
    )


class PrivateCancelRfqParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    rfq_id: UUID = Field(default_factory=uuid.uuid4)
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class Result(str, Enum):
    ok = "ok"


class PrivateCancelRfqResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: Result = Field(
        ...,
        description="The result of this method call, `ok` if successful",
        title="result",
    )


class PrivateCancelBatchRfqsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    label: Optional[str] = Field(
        None, description="Cancel RFQs with this label", title="label"
    )
    nonce: Optional[int] = Field(
        None, description="Cancel RFQ with this nonce", title="nonce"
    )
    rfq_id: Optional[UUID] = Field(None, description="RFQ ID to cancel", title="rfq_id")
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class PrivateCancelBatchRfqsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancelled_ids: List[UUID] = Field(
        ..., description="RFQ IDs of the cancelled RFQs", title="cancelled_ids"
    )


class PrivateCancelBatchQuotesParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    label: Optional[str] = Field(
        None, description="Cancel quotes with this label", title="label"
    )
    nonce: Optional[int] = Field(
        None, description="Cancel quote with this nonce", title="nonce"
    )
    quote_id: Optional[UUID] = Field(
        None, description="Quote ID to cancel", title="quote_id"
    )
    rfq_id: Optional[UUID] = Field(
        None, description="Cancel quotes for this RFQ ID", title="rfq_id"
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class PrivateCancelBatchQuotesResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancelled_ids: List[UUID] = Field(
        ..., description="Quote IDs of the cancelled quotes", title="cancelled_ids"
    )


PublicGetTimeParamsSchema = PublicGetMakerProgramsParamsSchema


class PublicGetTimeResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: int = Field(
        ..., description="Current time in milliseconds since UNIX epoch", title="result"
    )


class PrivateGetFundingHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_timestamp: int = Field(
        9223372036854776000,
        description="End timestamp of the event history (default current time)",
        title="end_timestamp",
    )
    instrument_name: Optional[str] = Field(
        None,
        description="Instrument name (returns history for all perpetuals if not provided)",
        title="instrument_name",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    start_timestamp: int = Field(
        0,
        description="Start timestamp of the event history (default 0)",
        title="start_timestamp",
    )
    subaccount_id: int = Field(..., description="Subaccount id", title="subaccount_id")


class FundingPaymentSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    funding: Decimal = Field(
        ...,
        description="Dollar funding paid (if negative) or received (if positive) by the subaccount",
        title="funding",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    pnl: Decimal = Field(
        ..., description="Cashflow from the perp PnL settlement", title="pnl"
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of the funding payment (in ms since UNIX epoch)",
        title="timestamp",
    )


class PrivateGetOpenOrdersParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to get open orders",
        title="subaccount_id",
    )


class PrivateGetOpenOrdersResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    orders: List[OrderResponseSchema] = Field(
        ..., description="List of open orders", title="orders"
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to get open orders",
        title="subaccount_id",
    )


PrivateGetAccountParamsSchema = PrivateGetSubaccountsParamsSchema


class AccountFeeInfoSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    base_fee_discount: Decimal = Field(
        ..., description="Base fee discount", title="base_fee_discount"
    )
    option_maker_fee: Optional[Decimal] = Field(
        ...,
        description="Option maker fee - uses default instrument fee rate if None",
        title="option_maker_fee",
    )
    option_taker_fee: Optional[Decimal] = Field(
        ...,
        description="Option taker fee - uses default instrument fee rate if None",
        title="option_taker_fee",
    )
    perp_maker_fee: Optional[Decimal] = Field(
        ...,
        description="Perp maker fee - uses default instrument fee rate if None",
        title="perp_maker_fee",
    )
    perp_taker_fee: Optional[Decimal] = Field(
        ...,
        description="Perp taker fee - uses default instrument fee rate if None",
        title="perp_taker_fee",
    )
    rfq_maker_discount: Decimal = Field(
        ..., description="RFQ maker fee discount", title="rfq_maker_discount"
    )
    rfq_taker_discount: Decimal = Field(
        ..., description="RFQ taker fee discount", title="rfq_taker_discount"
    )
    spot_maker_fee: Optional[Decimal] = Field(
        ...,
        description="Spot maker fee - uses default instrument fee rate if None",
        title="spot_maker_fee",
    )
    spot_taker_fee: Optional[Decimal] = Field(
        ...,
        description="Spot taker fee - uses default instrument fee rate if None",
        title="spot_taker_fee",
    )


class PublicGetAllInstrumentsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: Optional[str] = Field(
        None,
        description="Underlying currency of asset (`ETH`, `BTC`, etc)",
        title="currency",
    )
    expired: bool = Field(
        ..., description="If `True`: include expired instruments.", title="expired"
    )
    instrument_type: InstrumentType = Field(
        ..., description="`erc20`, `option`, or `perp`", title="instrument_type"
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )


class InstrumentPublicResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount_step: Decimal = Field(
        ..., description="Minimum valid increment of order amount", title="amount_step"
    )
    base_asset_address: str = Field(
        ...,
        description="Blockchain address of the base asset",
        title="base_asset_address",
    )
    base_asset_sub_id: str = Field(
        ...,
        description="Sub ID of the specific base asset as defined in Asset.sol",
        title="base_asset_sub_id",
    )
    base_currency: str = Field(
        ...,
        description="Underlying currency of base asset (`ETH`, `BTC`, etc)",
        title="base_currency",
    )
    base_fee: Decimal = Field(
        ..., description="$ base fee added to every taker order", title="base_fee"
    )
    erc20_details: Optional[ERC20PublicDetailsSchema] = Field(...)
    fifo_min_allocation: Decimal = Field(
        ...,
        description="Minimum number of contracts that get filled using FIFO. Actual number of contracts that gets filled by FIFO will be the max between this value and (1 - pro_rata_fraction) x order_amount, plus any size leftovers due to rounding.",
        title="fifo_min_allocation",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    instrument_type: InstrumentType = Field(
        ..., description="`erc20`, `option`, or `perp`", title="instrument_type"
    )
    is_active: bool = Field(
        ...,
        description="If `True`: instrument is tradeable within `activation` and `deactivation` timestamps",
        title="is_active",
    )
    maker_fee_rate: Decimal = Field(
        ...,
        description="Percent of spot price fee rate for makers",
        title="maker_fee_rate",
    )
    mark_price_fee_rate_cap: Optional[Decimal] = Field(
        None,
        description="Percent of option price fee cap, e.g. 12.5%, null if not applicable",
        title="mark_price_fee_rate_cap",
    )
    maximum_amount: Decimal = Field(
        ...,
        description="Maximum valid amount of contracts / tokens per trade",
        title="maximum_amount",
    )
    minimum_amount: Decimal = Field(
        ...,
        description="Minimum valid amount of contracts / tokens per trade",
        title="minimum_amount",
    )
    option_details: Optional[OptionPublicDetailsSchema] = Field(...)
    perp_details: Optional[PerpPublicDetailsSchema] = Field(...)
    pro_rata_amount_step: Decimal = Field(
        ...,
        description="Pro-rata fill share of every order is rounded down to be a multiple of this number. Leftovers of the order due to rounding are filled FIFO.",
        title="pro_rata_amount_step",
    )
    pro_rata_fraction: Decimal = Field(
        ...,
        description="Fraction of order that gets filled using pro-rata matching. If zero, the matching is full FIFO.",
        title="pro_rata_fraction",
    )
    quote_currency: str = Field(
        ...,
        description="Quote currency (`USD` for perps, `USDC` for options)",
        title="quote_currency",
    )
    scheduled_activation: int = Field(
        ...,
        description="Timestamp at which became or will become active (if applicable)",
        title="scheduled_activation",
    )
    scheduled_deactivation: int = Field(
        ...,
        description="Scheduled deactivation time for instrument (if applicable)",
        title="scheduled_deactivation",
    )
    taker_fee_rate: Decimal = Field(
        ...,
        description="Percent of spot price fee rate for takers",
        title="taker_fee_rate",
    )
    tick_size: Decimal = Field(
        ...,
        description="Tick size of the instrument, i.e. minimum price increment",
        title="tick_size",
    )


PublicGetTickerParamsSchema = PublicGetInstrumentParamsSchema


class OptionPricingSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    ask_iv: Decimal = Field(
        ..., description="Implied volatility of the current best ask", title="ask_iv"
    )
    bid_iv: Decimal = Field(
        ..., description="Implied volatility of the current best bid", title="bid_iv"
    )
    delta: Decimal = Field(..., description="Delta of the option", title="delta")
    discount_factor: Decimal = Field(
        ...,
        description="Discount factor used to calculate option premium",
        title="discount_factor",
    )
    forward_price: Decimal = Field(
        ...,
        description="Forward price used to calculate option premium",
        title="forward_price",
    )
    gamma: Decimal = Field(..., description="Gamma of the option", title="gamma")
    iv: Decimal = Field(..., description="Implied volatility of the option", title="iv")
    mark_price: Decimal = Field(
        ..., description="Mark price of the option", title="mark_price"
    )
    rho: Decimal = Field(..., description="Rho of the option", title="rho")
    theta: Decimal = Field(..., description="Theta of the option", title="theta")
    vega: Decimal = Field(..., description="Vega of the option", title="vega")


class AggregateTradingStatsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    contract_volume: Decimal = Field(
        ...,
        description="Number of contracts traded during last 24 hours",
        title="contract_volume",
    )
    high: Decimal = Field(
        ..., description="Highest trade price during last 24h", title="high"
    )
    low: Decimal = Field(
        ..., description="Lowest trade price during last 24h", title="low"
    )
    num_trades: Decimal = Field(
        ..., description="Number of trades during last 24h ", title="num_trades"
    )
    open_interest: Decimal = Field(
        ..., description="Current total open interest", title="open_interest"
    )
    percent_change: Decimal = Field(
        ...,
        description="24-hour price change expressed as a percentage. Options: percent change in vol; Perps: percent change in mark price",
        title="percent_change",
    )
    usd_change: Decimal = Field(
        ..., description="24-hour price change in USD.", title="usd_change"
    )


class PublicGetVaultShareParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    from_timestamp_sec: int = Field(
        ..., description="From timestamp in seconds", title="from_timestamp_sec"
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    to_timestamp_sec: int = Field(
        ..., description="To timestamp in seconds", title="to_timestamp_sec"
    )
    vault_name: str = Field(..., description="Name of the vault", title="vault_name")


class VaultShareResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    base_value: Decimal = Field(
        ...,
        description="The value of the vault's token against the base currency. Ex: rswETHC vs rswETH",
        title="base_value",
    )
    block_number: int = Field(
        ..., description="The Derive chain block number", title="block_number"
    )
    block_timestamp: int = Field(
        ...,
        description="Timestamp of the Derive chain block number",
        title="block_timestamp",
    )
    underlying_value: Optional[Decimal] = Field(
        ...,
        description="The value of the vault's token against the underlying currency. Ex: rswETHC vs ETH",
        title="underlying_value",
    )
    usd_value: Decimal = Field(
        ..., description="The value of the vault's token against USD", title="usd_value"
    )


PrivateGetCollateralsParamsSchema = PrivateGetPositionsParamsSchema


class CollateralResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Asset amount of given collateral", title="amount"
    )
    amount_step: Decimal = Field(
        ..., description="Minimum amount step for the collateral", title="amount_step"
    )
    asset_name: str = Field(..., description="Asset name", title="asset_name")
    asset_type: InstrumentType = Field(
        ...,
        description="Type of asset collateral (currently always `erc20`)",
        title="asset_type",
    )
    average_price: Decimal = Field(
        ...,
        description="Average price of the collateral, 0 for USDC.",
        title="average_price",
    )
    average_price_excl_fees: Decimal = Field(
        ...,
        description="Average price of whole position excluding fees",
        title="average_price_excl_fees",
    )
    creation_timestamp: int = Field(
        ...,
        description="Timestamp of when the position was opened (in ms since Unix epoch)",
        title="creation_timestamp",
    )
    cumulative_interest: Decimal = Field(
        ...,
        description="Cumulative interest earned on supplying collateral or paid for borrowing",
        title="cumulative_interest",
    )
    currency: str = Field(
        ...,
        description="Underlying currency of asset (`ETH`, `BTC`, etc)",
        title="currency",
    )
    delta: Decimal = Field(
        ..., description="Asset delta w.r.t. the delta currency", title="delta"
    )
    delta_currency: str = Field(
        ...,
        description="Currency with respect to which delta is reported.For example, LRTs like WEETH have their delta reported in ETH",
        title="delta_currency",
    )
    initial_margin: Decimal = Field(
        ...,
        description="USD value of collateral that contributes to initial margin",
        title="initial_margin",
    )
    maintenance_margin: Decimal = Field(
        ...,
        description="USD value of collateral that contributes to maintenance margin",
        title="maintenance_margin",
    )
    mark_price: Decimal = Field(
        ..., description="Current mark price of the asset", title="mark_price"
    )
    mark_value: Decimal = Field(
        ...,
        description="USD value of the collateral (amount * mark price)",
        title="mark_value",
    )
    open_orders_margin: Decimal = Field(
        ...,
        description="USD margin requirement for all open orders for this asset / instrument",
        title="open_orders_margin",
    )
    pending_interest: Decimal = Field(
        ...,
        description="Portion of interest that has not yet been settled on-chain. This number is added to the portfolio value for margin calculations purposes.",
        title="pending_interest",
    )
    realized_pnl: Decimal = Field(
        ...,
        description="Realized trading profit or loss of the collateral, 0 for USDC.",
        title="realized_pnl",
    )
    realized_pnl_excl_fees: Decimal = Field(
        ...,
        description="Realized trading profit or loss of the position excluding fees",
        title="realized_pnl_excl_fees",
    )
    total_fees: Decimal = Field(
        ...,
        description="Total fees paid for opening and changing the position",
        title="total_fees",
    )
    unrealized_pnl: Decimal = Field(
        ...,
        description="Unrealized trading profit or loss of the collateral, 0 for USDC.",
        title="unrealized_pnl",
    )
    unrealized_pnl_excl_fees: Decimal = Field(
        ...,
        description="Unrealized trading profit or loss of the position excluding fees",
        title="unrealized_pnl_excl_fees",
    )


class Scope(str, Enum):
    admin = "admin"
    account = "account"
    read_only = "read_only"


class PrivateRegisterScopedSessionKeyParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_sec: int = Field(
        ..., description="Expiry of the session key", title="expiry_sec"
    )
    ip_whitelist: Optional[List[str]] = Field(
        None,
        description="List of whitelisted IPs, if empty then any IP is allowed.",
        title="ip_whitelist",
    )
    label: Optional[str] = Field(
        None, description="User-defined session key label", title="label"
    )
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    scope: Scope = Field(
        "read_only",
        description="Scope of the session key. Defaults to READ_ONLY level permissions. ",
        title="scope",
    )
    signed_raw_tx: Optional[str] = Field(
        None,
        description="A signed RLP encoded ETH transaction in form of a hex string (same as `w3.eth.account.sign_transaction(unsigned_tx, private_key).rawTransaction.hex()`) Must be included if the scope is ADMIN.",
        title="signed_raw_tx",
    )
    wallet: str = Field(
        ..., description="Ethereum wallet address of account", title="wallet"
    )


class PrivateRegisterScopedSessionKeyResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiry_sec: int = Field(
        ..., description="Session key expiry timestamp in sec", title="expiry_sec"
    )
    ip_whitelist: Optional[List[str]] = Field(
        ...,
        description="List of whitelisted IPs, if empty then any IP is allowed.",
        title="ip_whitelist",
    )
    label: Optional[str] = Field(
        ..., description="User-defined session key label", title="label"
    )
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    scope: Scope = Field(
        ..., description="Session key permission level scope", title="scope"
    )
    transaction_id: Optional[UUID] = Field(
        ...,
        description="ID to lookup status of transaction if signed_raw_tx is provided",
        title="transaction_id",
    )


class PrivateExpiredAndCancelledHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_timestamp: int = Field(
        ..., description="End Unix timestamp", title="end_timestamp"
    )
    expiry: int = Field(
        ...,
        description="Expiry of download link in seconds. Maximum of 604800.",
        title="expiry",
    )
    start_timestamp: int = Field(
        ..., description="Start Unix timestamp", title="start_timestamp"
    )
    subaccount_id: int = Field(
        ..., description="Subaccount to download data for", title="subaccount_id"
    )
    wallet: str = Field(..., description="Wallet to download data for", title="wallet")


class PrivateExpiredAndCancelledHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    presigned_urls: List[str] = Field(
        ...,
        description="List of presigned URLs to the snapshots",
        title="presigned_urls",
    )


PrivateSessionKeysParamsSchema = PrivateGetSubaccountsParamsSchema


SessionKeyResponseSchema = PrivateEditSessionKeyResultSchema


class PrivateGetMmpConfigParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: Optional[str] = Field(
        None,
        description="Currency to get the config for. If not provided, returns all configs for the subaccount",
        title="currency",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to get the config",
        title="subaccount_id",
    )


class MMPConfigResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(
        ..., description="Currency of this mmp config", title="currency"
    )
    is_frozen: bool = Field(
        ..., description="Whether the subaccount is currently frozen", title="is_frozen"
    )
    mmp_amount_limit: Decimal = Field(
        "0",
        description="Maximum total order amount that can be traded within the mmp_interval across all instruments of the provided currency. The amounts are not netted, so a filled bid of 1 and a filled ask of 2 would count as 3.<br />Default: 0 (no limit)",
        title="mmp_amount_limit",
    )
    mmp_delta_limit: Decimal = Field(
        "0",
        description="Maximum total delta that can be traded within the mmp_interval across all instruments of the provided currency. This quantity is netted, so a filled order with +1 delta and a filled order with -2 delta would count as -1<br />Default: 0 (no limit)",
        title="mmp_delta_limit",
    )
    mmp_frozen_time: int = Field(
        ...,
        description="Time interval in ms setting how long the subaccount is frozen after an mmp trigger, if 0 then a manual reset would be required via private/reset_mmp",
        title="mmp_frozen_time",
    )
    mmp_interval: int = Field(
        ...,
        description="Time interval in ms over which the limits are monotored, if 0 then mmp is disabled",
        title="mmp_interval",
    )
    mmp_unfreeze_time: int = Field(
        ...,
        description="Timestamp in ms after which the subaccount will be unfrozen",
        title="mmp_unfreeze_time",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to set the config",
        title="subaccount_id",
    )


PrivateOrderParamsSchema = PrivateOrderDebugParamsSchema


class PrivateOrderResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    order: OrderResponseSchema
    trades: List[TradeResponseSchema] = Field(..., title="trades")


PrivateGetSubaccountParamsSchema = PrivateGetPositionsParamsSchema


class PrivateGetSubaccountResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    collaterals: List[CollateralResponseSchema] = Field(
        ...,
        description="All collaterals that count towards margin of subaccount",
        title="collaterals",
    )
    collaterals_initial_margin: Decimal = Field(
        ...,
        description="Total initial margin credit contributed by collaterals",
        title="collaterals_initial_margin",
    )
    collaterals_maintenance_margin: Decimal = Field(
        ...,
        description="Total maintenance margin credit contributed by collaterals",
        title="collaterals_maintenance_margin",
    )
    collaterals_value: Decimal = Field(
        ...,
        description="Total mark-to-market value of all collaterals",
        title="collaterals_value",
    )
    currency: str = Field(..., description="Currency of subaccount", title="currency")
    initial_margin: Decimal = Field(
        ...,
        description="Total initial margin requirement of all positions and collaterals.Trades will be rejected if this value falls below zero after the trade.",
        title="initial_margin",
    )
    is_under_liquidation: bool = Field(
        ...,
        description="Whether the subaccount is undergoing a liquidation auction",
        title="is_under_liquidation",
    )
    label: str = Field(..., description="User defined label", title="label")
    maintenance_margin: Decimal = Field(
        ...,
        description="Total maintenance margin requirement of all positions and collaterals.If this value falls below zero, the subaccount will be flagged for liquidation.",
        title="maintenance_margin",
    )
    margin_type: MarginType = Field(
        ...,
        description="Margin type of subaccount (`PM` (Portfolio Margin), `PM2 (Portfolio Margin 2), or `SM` (Standard Margin))",
        title="margin_type",
    )
    open_orders: List[OrderResponseSchema] = Field(
        ..., description="All open orders of subaccount", title="open_orders"
    )
    open_orders_margin: Decimal = Field(
        ...,
        description="Total margin requirement of all open orders.Orders will be rejected if this value plus initial margin are below zero after the order.",
        title="open_orders_margin",
    )
    positions: List[PositionResponseSchema] = Field(
        ..., description="All active positions of subaccount", title="positions"
    )
    positions_initial_margin: Decimal = Field(
        ...,
        description="Total initial margin requirement of all positions",
        title="positions_initial_margin",
    )
    positions_maintenance_margin: Decimal = Field(
        ...,
        description="Total maintenance margin requirement of all positions",
        title="positions_maintenance_margin",
    )
    positions_value: Decimal = Field(
        ...,
        description="Total mark-to-market value of all positions",
        title="positions_value",
    )
    projected_margin_change: Decimal = Field(
        ...,
        description="Projected change in maintenance margin requirement between now and projected margin at 8:01 UTC. If this value plus current maintenance margin ise below zero, the account is at risk of being flagged for liquidation right after the upcoming expiry.",
        title="projected_margin_change",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")
    subaccount_value: Decimal = Field(
        ...,
        description="Total mark-to-market value of all positions and collaterals",
        title="subaccount_value",
    )


class PublicGetInterestRateHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    from_timestamp_sec: int = Field(
        ..., description="From timestamp in seconds", title="from_timestamp_sec"
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    to_timestamp_sec: int = Field(
        ..., description="To timestamp in seconds", title="to_timestamp_sec"
    )


class InterestRateHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    block: int = Field(..., description="Derive Chain block number", title="block")
    borrow_apy: Decimal = Field(..., description="Borrow APY", title="borrow_apy")
    supply_apy: Decimal = Field(..., description="Supply APY", title="supply_apy")
    timestamp_sec: int = Field(
        ..., description="Timestamp in seconds", title="timestamp_sec"
    )
    total_borrow: Decimal = Field(
        ..., description="Total USDC borrowed", title="total_borrow"
    )
    total_supply: Decimal = Field(
        ..., description="Total USDC supplied", title="total_supply"
    )


class PrivateGetAllPortfoliosParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    wallet: str = Field(..., description="Wallet address", title="wallet")


class PrivateGetAllPortfoliosResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[PrivateGetSubaccountResultSchema] = Field(
        ..., description="", title="result"
    )


class PublicGetLiquidationHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_timestamp: int = Field(
        9223372036854776000,
        description="End timestamp of the event history (default current time)",
        title="end_timestamp",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    start_timestamp: int = Field(
        0,
        description="Start timestamp of the event history (default 0)",
        title="start_timestamp",
    )
    subaccount_id: Optional[int] = Field(
        None, description="(Optional) Subaccount ID", title="subaccount_id"
    )


class PublicDepositDebugParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount of the asset to deposit", title="amount"
    )
    asset_name: str = Field(
        ..., description="Name of asset to deposit", title="asset_name"
    )
    is_atomic_signing: bool = Field(
        False,
        description="Used by vaults to determine whether the signature is an EIP-1271 signature",
        title="is_atomic_signing",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be >5min from now",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Ethereum wallet address that is signing the deposit",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


PublicDepositDebugResultSchema = PublicCreateSubaccountDebugResultSchema


class PublicGetVaultBalancesParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    smart_contract_owner: Optional[str] = Field(
        None,
        description="If wallet not provided, can query balances by EOA that owns smart contract wallet",
        title="smart_contract_owner",
    )
    wallet: Optional[str] = Field(
        None, description="Ethereum wallet address of smart contract", title="wallet"
    )


class VaultBalanceResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    address: str = Field(..., title="address")
    amount: Decimal = Field(..., title="amount")
    chain_id: int = Field(..., title="chain_id")
    name: str = Field(..., title="name")
    vault_asset_type: str = Field(..., title="vault_asset_type")


class PublicGetReferralPerformanceParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_ms: int = Field(
        ..., description="End timestamp in UTC milliseconds", title="end_ms"
    )
    referral_code: Optional[str] = Field(
        None, description="(Optional) referral code", title="referral_code"
    )
    start_ms: int = Field(
        ..., description="Start timestamp in UTC milliseconds", title="start_ms"
    )
    wallet: Optional[str] = Field(
        None, description="(Optional) wallet of the referrer", title="wallet"
    )


class ReferralPerformanceByInstrumentTypeSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fee_reward: Decimal = Field(
        ..., description="Fee reward to referrer", title="fee_reward"
    )
    notional_volume: Decimal = Field(
        ..., description="Notional volume", title="notional_volume"
    )
    referred_fee: Decimal = Field(
        ..., description="Fees paid by referred trader", title="referred_fee"
    )


class PrivateSetCancelOnDisconnectParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    enabled: bool = Field(
        ...,
        description="Whether to enable or disable cancel on disconnect",
        title="enabled",
    )
    wallet: str = Field(
        ..., description="Public key (wallet) of the account", title="wallet"
    )


class PrivateSetCancelOnDisconnectResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: Result = Field(..., description="", title="result")


class PrivateCancelQuoteParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    quote_id: UUID = Field(default_factory=uuid.uuid4)
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


PrivateCancelQuoteResultSchema = QuoteResultSchema


class PrivateGetQuotesParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    from_timestamp: int = Field(
        0,
        description="Earliest timestamp to filter by (in ms since Unix epoch). If not provied, defaults to 0.",
        title="from_timestamp",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    quote_id: Optional[UUID] = Field(
        None, description="Quote ID filter, if applicable", title="quote_id"
    )
    rfq_id: Optional[UUID] = Field(
        None, description="RFQ ID filter, if applicable", title="rfq_id"
    )
    status: Optional[Status1] = Field(
        None, description="Quote status filter, if applicable", title="status"
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount ID for auth purposes, returned data will be scoped to this subaccount.",
        title="subaccount_id",
    )
    to_timestamp: int = Field(
        18446744073709552000,
        description="Latest timestamp to filter by (in ms since Unix epoch). If not provied, defaults to returning all data up to current time.",
        title="to_timestamp",
    )


class PrivateGetQuotesResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    quotes: List[QuoteResultSchema] = Field(
        ..., description="Quotes matching filter criteria", title="quotes"
    )


class PublicExecuteQuoteDebugParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    direction: Direction = Field(
        ...,
        description="Quote direction, `buy` means trading each leg at its direction, `sell` means trading each leg in the opposite direction.",
        title="direction",
    )
    enable_taker_protection: bool = Field(
        False,
        description="Whether taker protection is enabled for the quote",
        title="enable_taker_protection",
    )
    label: str = Field(
        "", description="Optional user-defined label for the quote", title="label"
    )
    legs: List[LegPricedSchema] = Field(..., description="Quote legs", title="legs")
    max_fee: Decimal = Field(
        ...,
        description="Max fee ($ for the full trade). Request will be rejected if the supplied max fee is below the estimated fee for this trade.",
        title="max_fee",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as a concatenated `UTC timestamp in ms` and `random number up to 6 digits` (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    quote_id: UUID = Field(default_factory=uuid.uuid4)
    rfq_id: UUID = Field(default_factory=uuid.uuid4)
    signature: str = Field(
        ..., description="Ethereum signature of the quote", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be at least 310 seconds from now. Once time till signature expiry reaches 300 seconds, the quote will be considered expired. This buffer is meant to ensure the trade can settle on chain in case of a blockchain congestion.",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed the quote",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class PublicExecuteQuoteDebugResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    action_hash: str = Field(
        ..., description="Keccak hashed action data", title="action_hash"
    )
    encoded_data: str = Field(
        ..., description="ABI encoded deposit data", title="encoded_data"
    )
    encoded_data_hashed: str = Field(
        ..., description="Keccak hashed encoded_data", title="encoded_data_hashed"
    )
    encoded_legs: str = Field(
        ..., description="ABI encoded legs data", title="encoded_legs"
    )
    legs_hash: str = Field(
        ..., description="Keccak hashed legs data", title="legs_hash"
    )
    typed_data_hash: str = Field(
        ..., description="EIP 712 typed data hash", title="typed_data_hash"
    )


class PrivateGetOptionSettlementHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount ID for which to get expired option settlement history",
        title="subaccount_id",
    )


class OptionSettlementResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(..., description="Amount that was settled", title="amount")
    expiry: int = Field(
        ..., description="Expiry timestamp of the option", title="expiry"
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    option_settlement_pnl: Decimal = Field(
        ...,
        description="USD profit or loss from option settlements calculated as: settlement value - (average cost including fees x amount)",
        title="option_settlement_pnl",
    )
    option_settlement_pnl_excl_fees: Decimal = Field(
        ...,
        description="USD profit or loss from option settlements calculated as: settlement value - (average price excluding fees x amount)",
        title="option_settlement_pnl_excl_fees",
    )
    settlement_price: Decimal = Field(
        ..., description="Price of option settlement", title="settlement_price"
    )
    subaccount_id: int = Field(
        ..., description="Subaccount ID of the settlement event", title="subaccount_id"
    )


class PrivateResetMmpParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: Optional[str] = Field(
        None,
        description="Currency to reset the mmp for. If not provided, resets all configs for the subaccount",
        title="currency",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to reset the mmp state",
        title="subaccount_id",
    )


PrivateResetMmpResponseSchema = PrivateCancelRfqResponseSchema


PrivateGetErc20TransferHistoryParamsSchema = PrivateGetLiquidationHistoryParamsSchema


class ERC20TransferSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount withdrawn by the subaccount", title="amount"
    )
    asset: str = Field(..., description="Asset withdrawn", title="asset")
    counterparty_subaccount_id: int = Field(
        ...,
        description="Recipient or sender subaccount_id of transfer",
        title="counterparty_subaccount_id",
    )
    is_outgoing: bool = Field(
        ...,
        description="True if the transfer was initiated by the subaccount, False otherwise",
        title="is_outgoing",
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of the transfer (in ms since UNIX epoch)",
        title="timestamp",
    )
    tx_hash: str = Field(
        ...,
        description="Hash of the transaction that withdrew the funds",
        title="tx_hash",
    )


PublicGetAllCurrenciesParamsSchema = PublicGetMakerProgramsParamsSchema


class CurrencyDetailedResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    asset_cap_and_supply_per_manager: Dict[
        str, Dict[str, List[OpenInterestStatsSchema]]
    ] = Field(
        ...,
        description="Current open interest and open interest cap by manager and asset type",
        title="asset_cap_and_supply_per_manager",
    )
    borrow_apy: Decimal = Field(
        ..., description="Borrow APY (only for USDC)", title="borrow_apy"
    )
    currency: str = Field(
        ...,
        description="Underlying currency of asset (`ETH`, `BTC`, etc)",
        title="currency",
    )
    erc20_details: Optional[Dict[str, Optional[str]]] = Field(
        None,
        description="Details of the erc20 asset (if applicable)",
        title="erc20_details",
    )
    instrument_types: List[InstrumentType] = Field(
        ...,
        description="Instrument types supported for the currency",
        title="instrument_types",
    )
    managers: List[ManagerContractResponseSchema] = Field(
        ..., description="Managers supported for the currency", title="managers"
    )
    market_type: MarketType = Field(
        ..., description="Market type of the currency", title="market_type"
    )
    pm2_collateral_discounts: List[PM2CollateralDiscountsSchema] = Field(
        ...,
        description="Initial and Maintenance Margin discounts for given collateral in PM2",
        title="pm2_collateral_discounts",
    )
    protocol_asset_addresses: ProtocolAssetAddressesSchema
    spot_price: Decimal = Field(
        ..., description="Spot price of the currency", title="spot_price"
    )
    spot_price_24h: Optional[Decimal] = Field(
        None,
        description="Spot price of the currency 24 hours ago",
        title="spot_price_24h",
    )
    srm_im_discount: Decimal = Field(
        ...,
        description="Initial Margin discount for given collateral in Standard Manager (e.g. LTV). Only the Standard Manager supports non-USDC collateral",
        title="srm_im_discount",
    )
    srm_mm_discount: Decimal = Field(
        ...,
        description="Maintenance Margin discount for given collateral in Standard Manager (e.g. liquidation threshold). Only the Standard Manager supports non-USDC collateral",
        title="srm_mm_discount",
    )
    supply_apy: Decimal = Field(
        ..., description="Supply APY (only for USDC)", title="supply_apy"
    )
    total_borrow: Decimal = Field(
        ...,
        description="Total collateral borrowed in the protocol (only USDC is borrowable)",
        title="total_borrow",
    )
    total_supply: Decimal = Field(
        ...,
        description="Total collateral supplied in the protocol",
        title="total_supply",
    )


class PrivateGetSubaccountValueHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_timestamp: int = Field(..., description="End timestamp", title="end_timestamp")
    period: int = Field(..., description="Period", title="period")
    start_timestamp: int = Field(
        ..., description="Start timestamp", title="start_timestamp"
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class SubAccountValueHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subaccount_value: Decimal = Field(
        ...,
        description="Total mark-to-market value of all positions and collaterals",
        title="subaccount_value",
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of when the subaccount value was recorded into the database",
        title="timestamp",
    )


PublicSendQuoteDebugParamsSchema = PrivateSendQuoteParamsSchema


PublicSendQuoteDebugResultSchema = PublicCreateSubaccountDebugResultSchema


PublicGetLiveIncidentsParamsSchema = PublicGetMakerProgramsParamsSchema


class MonitorType(str, Enum):
    manual = "manual"
    auto = "auto"


class Severity(str, Enum):
    low = "low"
    medium = "medium"
    high = "high"


class IncidentResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    creation_timestamp_sec: int = Field(
        ...,
        description="Timestamp of incident in UTC sec",
        title="creation_timestamp_sec",
    )
    label: str = Field(..., description="Incident label", title="label")
    message: str = Field(..., description="Incident message", title="message")
    monitor_type: MonitorType = Field(
        ..., description="Incident trigger type", title="monitor_type"
    )
    severity: Severity = Field(..., description="Incident severity", title="severity")


class PublicGetTransactionParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    transaction_id: UUID = Field(default_factory=uuid.uuid4)


class PublicGetTransactionResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    data: str = Field(..., description="Data used to create transaction", title="data")
    error_log: Optional[str] = Field(
        ..., description="Error log if failed tx", title="error_log"
    )
    status: TxStatus = Field(
        ..., description="Status of the transaction", title="status"
    )
    transaction_hash: Optional[str] = Field(
        ..., description="Transaction hash of a pending tx", title="transaction_hash"
    )


class PrivateGetOrdersParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    instrument_name: Optional[str] = Field(
        None, description="Filter by instrument name", title="instrument_name"
    )
    label: Optional[str] = Field(None, description="Filter by label", title="label")
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    status: Optional[OrderStatus] = Field(
        None, description="Filter by order status", title="status"
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to get open orders",
        title="subaccount_id",
    )


PrivateGetOrdersResultSchema = PrivateGetOrderHistoryResultSchema


PrivateGetInterestHistoryParamsSchema = PrivateGetLiquidationHistoryParamsSchema


class InterestPaymentSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    interest: Decimal = Field(
        ...,
        description="Dollar interest paid (if negative) or received (if positive) by the subaccount",
        title="interest",
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of the interest payment (in ms since UNIX epoch)",
        title="timestamp",
    )


PrivatePollQuotesParamsSchema = PrivateGetQuotesParamsSchema


class QuoteResultPublicSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancel_reason: CancelReason1 = Field(
        ..., description="Cancel reason, if any", title="cancel_reason"
    )
    creation_timestamp: int = Field(
        ...,
        description="Creation timestamp in ms since Unix epoch",
        title="creation_timestamp",
    )
    direction: Direction = Field(..., description="Quote direction", title="direction")
    fill_pct: Decimal = Field(
        ...,
        description="Percentage of the RFQ that this quote would fill, from 0 to 1.",
        title="fill_pct",
    )
    last_update_timestamp: int = Field(
        ...,
        description="Last update timestamp in ms since Unix epoch",
        title="last_update_timestamp",
    )
    legs: List[LegPricedSchema] = Field(..., description="Quote legs", title="legs")
    legs_hash: str = Field(
        ...,
        description="Hash of the legs of the best quote to be signed by the taker.",
        title="legs_hash",
    )
    liquidity_role: LiquidityRole = Field(
        ..., description="Liquidity role", title="liquidity_role"
    )
    quote_id: UUID = Field(..., description="Quote ID", title="quote_id")
    rfq_id: UUID = Field(..., description="RFQ ID", title="rfq_id")
    status: Status1 = Field(..., description="Status", title="status")
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    tx_hash: Optional[str] = Field(
        ...,
        description="Blockchain transaction hash (only for executed quotes)",
        title="tx_hash",
    )
    tx_status: Optional[TxStatus] = Field(
        ...,
        description="Blockchain transaction status (only for executed quotes)",
        title="tx_status",
    )
    wallet: str = Field(
        ..., description="Wallet address of the quote sender", title="wallet"
    )


class PrivateGetOrderParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    order_id: str = Field(..., description="Order ID", title="order_id")
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


PrivateGetOrderResultSchema = OrderResponseSchema


PublicGetVaultStatisticsParamsSchema = PublicGetMakerProgramsParamsSchema


class VaultStatisticsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    base_value: Decimal = Field(
        ...,
        description="The value of the vault's token against the base currency. Ex: rswETHC vs rswETH",
        title="base_value",
    )
    block_number: int = Field(
        ..., description="The Derive chain block number", title="block_number"
    )
    block_timestamp: int = Field(
        ...,
        description="Timestamp of the Derive chain block number",
        title="block_timestamp",
    )
    subaccount_value_at_last_trade: Optional[Decimal] = Field(
        ...,
        description="Will return None before vault creates subaccount or if no trades found.",
        title="subaccount_value_at_last_trade",
    )
    total_supply: Decimal = Field(
        ...,
        description="Total supply of the vault's token on Derive chain",
        title="total_supply",
    )
    underlying_value: Optional[Decimal] = Field(
        ...,
        description="The value of the vault's token against the underlying currency. Ex: rswETHC vs ETH",
        title="underlying_value",
    )
    usd_tvl: Decimal = Field(
        ..., description="Total USD TVL of the vault", title="usd_tvl"
    )
    usd_value: Decimal = Field(
        ..., description="The value of the vault's token against USD", title="usd_value"
    )
    vault_name: str = Field(..., description="Name of the vault", title="vault_name")


class PublicWithdrawDebugParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount of the asset to withdraw", title="amount"
    )
    asset_name: str = Field(
        ..., description="Name of asset to withdraw", title="asset_name"
    )
    is_atomic_signing: bool = Field(
        False,
        description="Used by vaults to determine whether the signature is an EIP-1271 signature",
        title="is_atomic_signing",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be >5min from now",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Ethereum wallet address that is signing the withdraw",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


PublicWithdrawDebugResultSchema = PublicCreateSubaccountDebugResultSchema


class Period1(str, Enum):
    field_900 = 900
    field_3600 = 3600
    field_14400 = 14400
    field_28800 = 28800
    field_86400 = 86400


class PublicGetFundingRateHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    end_timestamp: int = Field(
        9223372036854776000,
        description="End timestamp of the event history (default current time)",
        title="end_timestamp",
    )
    instrument_name: str = Field(
        ...,
        description="Instrument name to return funding history for",
        title="instrument_name",
    )
    period: Period1 = Field(
        3600, description="Period of the funding rate", title="period"
    )
    start_timestamp: int = Field(
        0,
        description="Start timestamp of the event history (default 0)",
        title="start_timestamp",
    )


class FundingRateSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    funding_rate: Decimal = Field(
        ...,
        description="Hourly funding rate value at the event time",
        title="funding_rate",
    )
    timestamp: int = Field(
        ...,
        description="Timestamp of the funding rate update (in ms since UNIX epoch)",
        title="timestamp",
    )


class PrivateRfqGetBestQuoteParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    counterparties: Optional[List[str]] = Field(
        None,
        description="Optional list of market maker account addresses to request quotes from. If not supplied, all market makers who are approved as RFQ makers will be notified.",
        title="counterparties",
    )
    direction: Direction = Field(
        "buy",
        description="Planned execution direction (default `buy`)",
        title="direction",
    )
    label: str = Field(
        "", description="Optional user-defined label for the RFQ", title="label"
    )
    legs: List[LegUnpricedSchema] = Field(..., description="RFQ legs", title="legs")
    max_total_cost: Optional[Decimal] = Field(
        None,
        description="An optional max total cost for the RFQ. Only used when the RFQ sender executes as buyer. Polling endpoints and channels will ignore quotes where the total cost across all legs is above this value. Positive values mean the RFQ sender expects to pay $, negative mean the RFQ sender expects to receive $.This field is not disclosed to the market makers.",
        title="max_total_cost",
    )
    min_total_cost: Optional[Decimal] = Field(
        None,
        description="An optional min total cost for the RFQ. Only used when the RFQ sender executes as seller. Polling endpoints and channels will ignore quotes where the total cost across all legs is below this value. Positive values mean the RFQ sender expects to receive $, negative mean the RFQ sender expects to pay $.This field is not disclosed to the market makers.",
        title="min_total_cost",
    )
    partial_fill_step: Decimal = Field(
        "1",
        description="Optional step size for partial fills. If not supplied, the RFQ will not support partial fills.",
        title="partial_fill_step",
    )
    rfq_id: Optional[UUID] = Field(
        None,
        description="RFQ ID to get best quote for. If not provided, will return estimates based on mark prices",
        title="rfq_id",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class InvalidReason(str, Enum):
    Account_is_currently_under_maintenance_margin_requirements__trading_is_frozen_ = (
        "Account is currently under maintenance margin requirements, trading is frozen."
    )
    This_order_would_cause_account_to_fall_under_maintenance_margin_requirements_ = (
        "This order would cause account to fall under maintenance margin requirements."
    )
    Insufficient_buying_power__only_a_single_risk_reducing_open_order_is_allowed_ = (
        "Insufficient buying power, only a single risk-reducing open order is allowed."
    )
    Insufficient_buying_power__consider_reducing_order_size_ = (
        "Insufficient buying power, consider reducing order size."
    )
    Insufficient_buying_power__consider_reducing_order_size_or_canceling_other_orders_ = "Insufficient buying power, consider reducing order size or canceling other orders."
    Consider_canceling_other_limit_orders_or_using_IOC__FOK__or_market_orders__This_order_is_risk_reducing__but_if_filled_with_other_open_orders__buying_power_might_be_insufficient_ = "Consider canceling other limit orders or using IOC, FOK, or market orders. This order is risk-reducing, but if filled with other open orders, buying power might be insufficient."
    Insufficient_buying_power_ = "Insufficient buying power."


class PrivateRfqGetBestQuoteResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    best_quote: Optional[QuoteResultPublicSchema] = Field(...)
    direction: Direction = Field(..., description="RFQ direction.", title="direction")
    down_liquidation_price: Optional[Decimal] = Field(
        ...,
        description="Liquidation price if the trade were to be filled and the market moves down.",
        title="down_liquidation_price",
    )
    estimated_fee: Decimal = Field(
        ...,
        description="An estimate for how much the user will pay in fees ($ for the whole trade).",
        title="estimated_fee",
    )
    estimated_realized_pnl: Decimal = Field(
        ...,
        description="An estimate for the realized PnL of the trade.",
        title="estimated_realized_pnl",
    )
    estimated_realized_pnl_excl_fees: Decimal = Field(
        ...,
        description="An estimate for the realized PnL of the trade. with cost basis calculated without considering fees.",
        title="estimated_realized_pnl_excl_fees",
    )
    estimated_total_cost: Decimal = Field(
        ...,
        description="An estimate for the total $ cost of the trade.",
        title="estimated_total_cost",
    )
    filled_pct: Decimal = Field(
        ...,
        description="Percentage of the RFQ that has already been filled, from 0 to 1.",
        title="filled_pct",
    )
    invalid_reason: Optional[InvalidReason] = Field(
        ...,
        description="Reason for the RFQ being invalid, if any.",
        title="invalid_reason",
    )
    is_valid: bool = Field(
        ...,
        description="`True` if RFQ is expected to pass margin requirements.",
        title="is_valid",
    )
    orderbook_total_cost: Optional[Decimal] = Field(
        ...,
        description="Total cost of  the RFQ if it were to be filled at current orderbook prices (same direction as the RFQ). If lower than `estimated_total_cost`, the user may want to use the orderbook instead of RFQs for this order. Will return null if any of the legs do not have orderbook data or enough liquidity for the full fill.",
        title="orderbook_total_cost",
    )
    post_initial_margin: Decimal = Field(
        ...,
        description="User's hypothetical margin balance if the trade were to get executed.",
        title="post_initial_margin",
    )
    post_liquidation_price: Optional[Decimal] = Field(
        ...,
        description="Liquidation price if the trade were to be filled. If both upside and downside liquidation prices exist, returns the closest one to the current index price.",
        title="post_liquidation_price",
    )
    pre_initial_margin: Decimal = Field(
        ...,
        description="User's initial margin balance before the trade.",
        title="pre_initial_margin",
    )
    suggested_max_fee: Decimal = Field(
        ...,
        description="Recommended value for `max_fee` of the trade.",
        title="suggested_max_fee",
    )
    up_liquidation_price: Optional[Decimal] = Field(
        ...,
        description="Liquidation price if the trade were to be filled and the market moves up.",
        title="up_liquidation_price",
    )


class PublicGetInstrumentsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(
        ...,
        description="Underlying currency of asset (`ETH`, `BTC`, etc)",
        title="currency",
    )
    expired: bool = Field(
        ...,
        description="If `True`: include expired assets. Note: will soon be capped up to only 1 week in the past.",
        title="expired",
    )
    instrument_type: InstrumentType = Field(
        ..., description="`erc20`, `option`, or `perp`", title="instrument_type"
    )


class PublicGetInstrumentsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[InstrumentPublicResponseSchema] = Field(
        ..., description="", title="result"
    )


class PublicGetOptionSettlementHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    subaccount_id: Optional[int] = Field(
        None,
        description="Subaccount ID filter (defaults to all if not provided)",
        title="subaccount_id",
    )


class PublicGetOptionSettlementHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    settlements: List[OptionSettlementResponseSchema] = Field(
        ..., description="List of expired option settlements", title="settlements"
    )


class PrivateLiquidateParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cash_transfer: Decimal = Field(
        ...,
        description="Amount of cash to transfer to a newly created subaccount for bidding. Must be non-negative.",
        title="cash_transfer",
    )
    last_seen_trade_id: int = Field(
        ...,
        description="Last seen trade ID for account being liquidated. Not checked if set to 0.",
        title="last_seen_trade_id",
    )
    liquidated_subaccount_id: int = Field(
        ...,
        description="Subaccount ID of the account to be liquidated.",
        title="liquidated_subaccount_id",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    percent_bid: Decimal = Field(
        ...,
        description="Percent of the liquidated position to bid for. Will bid for the maximum possible percent of the position if set to 1",
        title="percent_bid",
    )
    price_limit: Decimal = Field(
        ...,
        description="Maximum amount of cash to be paid from bidder to liquidated account (supports negative amounts for insolvent auctions). Not checked if set to 0.",
        title="price_limit",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the order", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Order signature becomes invalid after this time, and the system will cancel the order.Expiry MUST be at least 5 min from now.",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed order",
        title="signer",
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount ID owned by wallet, that will be doing the bidding.",
        title="subaccount_id",
    )


class PrivateLiquidateResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    estimated_bid_price: Decimal = Field(
        ...,
        description="Estimated bid price for this liquidation",
        title="estimated_bid_price",
    )
    estimated_discount_pnl: Decimal = Field(
        ...,
        description="Estimated profit (increase in the subaccount mark value) if the liquidation is successful.",
        title="estimated_discount_pnl",
    )
    estimated_percent_bid: Decimal = Field(
        ...,
        description="Estimated percent of account the bid will aquire",
        title="estimated_percent_bid",
    )
    transaction_id: UUID = Field(
        ...,
        description="The transaction id of the related settlement transaction",
        title="transaction_id",
    )


class PrivateGetTradeHistoryParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    from_timestamp: int = Field(
        0,
        description="Earliest timestamp to filter by (in ms since Unix epoch). If not provied, defaults to 0.",
        title="from_timestamp",
    )
    instrument_name: Optional[str] = Field(
        None, description="Instrument name to filter by", title="instrument_name"
    )
    order_id: Optional[str] = Field(
        None, description="Order id to filter by", title="order_id"
    )
    page: int = Field(
        1,
        description="Page number of results to return (default 1, returns last if above `num_pages`)",
        title="page",
    )
    page_size: int = Field(
        100,
        description="Number of results per page (default 100, max 1000)",
        title="page_size",
    )
    quote_id: Optional[str] = Field(
        None,
        description="If supplied, quote id to filter by. Supports either a concrete UUID, or `is_quote` and `is_not_quote` enum",
        title="quote_id",
    )
    subaccount_id: Optional[int] = Field(
        None,
        description="Subaccount_id (must be set if wallet is blank)",
        title="subaccount_id",
    )
    to_timestamp: int = Field(
        18446744073709552000,
        description="Latest timestamp to filter by (in ms since Unix epoch). If not provied, defaults to returning all data up to current time.",
        title="to_timestamp",
    )
    wallet: Optional[str] = Field(
        None,
        description="Wallet address (if set, subaccount_id ignored)",
        title="wallet",
    )


class PrivateGetTradeHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    subaccount_id: int = Field(
        ...,
        description="Subaccount ID requested, or 0 if not provided",
        title="subaccount_id",
    )
    trades: List[TradeResponseSchema] = Field(
        ..., description="List of trades", title="trades"
    )


class PublicGetLatestSignedFeedsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: Optional[str] = Field(
        None,
        description="Currency filter, (defaults to all currencies)",
        title="currency",
    )
    expiry: Optional[int] = Field(
        None,
        description="Expiry filter for options and forward data (defaults to all expiries). Use `0` to get data only for spot and perpetuals",
        title="expiry",
    )


class OracleSignatureDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    signatures: Optional[List[str]] = Field(
        None, description="The signatures of the given signers", title="signatures"
    )
    signers: Optional[List[str]] = Field(
        None, description="The signers who verify the data integrity", title="signers"
    )


class Type(str, Enum):
    P = "P"
    A = "A"
    B = "B"


class PerpFeedDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    confidence: Decimal = Field(
        ..., description="The confidence score of the price", title="confidence"
    )
    currency: str = Field(
        ...,
        description="The currency for which the spot feed represents",
        title="currency",
    )
    deadline: int = Field(
        ...,
        description="The latest time the data can be submitted on chain",
        title="deadline",
    )
    signatures: OracleSignatureDataSchema
    spot_diff_value: Decimal = Field(
        ...,
        description="The difference between the spot price and the perp price",
        title="spot_diff_value",
    )
    timestamp: int = Field(
        ...,
        description="The timestamp for which the data was created",
        title="timestamp",
    )
    type: Type = Field(
        ...,
        description="The type of perp feed; mid price, ask impact or bid impact",
        title="type",
    )


class RateFeedDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    confidence: Decimal = Field(
        ..., description="The confidence score of the rate", title="confidence"
    )
    currency: str = Field(
        ...,
        description="The currency for which the spot feed represents",
        title="currency",
    )
    deadline: int = Field(
        ...,
        description="The latest time the data can be submitted on chain",
        title="deadline",
    )
    expiry: int = Field(..., description="The expiry for the rate feed", title="expiry")
    rate: Decimal = Field(
        ..., description="The implied rate for the currency/expiry", title="rate"
    )
    signatures: OracleSignatureDataSchema
    timestamp: int = Field(
        ...,
        description="The timestamp for which the data was created",
        title="timestamp",
    )


class FeedSourceType(str, Enum):
    S = "S"
    O = "O"


class SpotFeedDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    confidence: Decimal = Field(
        ..., description="The confidence score of the price", title="confidence"
    )
    currency: str = Field(
        ...,
        description="The currency for which the spot feed represents",
        title="currency",
    )
    deadline: int = Field(
        ...,
        description="The latest time the data can be submitted on chain",
        title="deadline",
    )
    feed_source_type: FeedSourceType = Field(
        "S", description="The source of the feed", title="feed_source_type"
    )
    price: Decimal = Field(
        ..., description="The price of the currency in USD", title="price"
    )
    signatures: OracleSignatureDataSchema
    timestamp: int = Field(
        ...,
        description="The timestamp for which the data was created",
        title="timestamp",
    )


class VolSVIParamDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    SVI_a: Decimal = Field(..., title="SVI_a")
    SVI_b: Decimal = Field(..., title="SVI_b")
    SVI_fwd: Decimal = Field(..., title="SVI_fwd")
    SVI_m: Decimal = Field(..., title="SVI_m")
    SVI_refTau: Decimal = Field(..., title="SVI_refTau")
    SVI_rho: Decimal = Field(..., title="SVI_rho")
    SVI_sigma: Decimal = Field(..., title="SVI_sigma")


class PrivateReplaceParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Order amount in units of the base", title="amount"
    )
    direction: Direction = Field(..., description="Order direction", title="direction")
    expected_filled_amount: Optional[Decimal] = Field(
        None,
        description="Optional check to only create new order if old order filled_amount is equal to this value.",
        title="expected_filled_amount",
    )
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    is_atomic_signing: Optional[bool] = Field(
        False,
        description="Used by vaults to determine whether the signature is an EIP-1271 signature.",
        title="is_atomic_signing",
    )
    label: str = Field(
        "", description="Optional user-defined label for the order", title="label"
    )
    limit_price: Decimal = Field(
        ...,
        description="Limit price in quote currency.<br />This field is still required for market orders because it is a component of the signature. However, market orders will not leave a resting order in the book in case of a partial fill.",
        title="limit_price",
    )
    max_fee: Decimal = Field(
        ...,
        description="Max fee per unit of volume, denominated in units of the quote currency (usually USDC).Order will be rejected if the supplied max fee is below the estimated fee for this order.",
        title="max_fee",
    )
    mmp: bool = Field(
        False,
        description="Whether the order is tagged for market maker protections (default false)",
        title="mmp",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_3_digits> (e.g. 1695836058725001, where 001 is the random number).Note, using a random number beyond 3 digits will cause JSON serialization to fail.",
        title="nonce",
    )
    nonce_to_cancel: Optional[int] = Field(
        None,
        description="Cancel order by nonce (choose either order_id or nonce).",
        title="nonce_to_cancel",
    )
    order_id_to_cancel: Optional[UUID] = Field(
        None,
        description="Cancel order by order_id (choose either order_id or nonce).",
        title="order_id_to_cancel",
    )
    order_type: OrderType = Field(
        "limit",
        description="Order type:<br />- `limit`: limit order (default)<br />- `market`: market order, note that limit_price is still required for market orders, but unfilled order portion will be marked as cancelled",
        title="order_type",
    )
    reduce_only: bool = Field(
        False,
        description="If true, the order will not be able to increase position's size (default false). If the order amount exceeds available position size, the order will be filled up to the position size and the remainder will be cancelled. This flag is only supported for market orders or non-resting limit orders (IOC or FOK)",
        title="reduce_only",
    )
    referral_code: str = Field(
        "", description="Optional referral code for the order", title="referral_code"
    )
    reject_timestamp: int = Field(
        9223372036854776000,
        description="UTC timestamp in ms, if provided the matching engine will reject the order with an error if `reject_timestamp` < `server_time`. Note that the timestamp must be consistent with the server time: use `public/get_time` method to obtain current server time.",
        title="reject_timestamp",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the order", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Order signature becomes invalid after this time, and the system will cancel the order.Expiry MUST be at least 5 min from now.",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Owner wallet address or registered session key that signed order",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")
    time_in_force: TimeInForce = Field(
        "gtc",
        description="Time in force behaviour:<br />- `gtc`: good til cancelled (default)<br />- `post_only`: a limit order that will be rejected if it crosses any order in the book, i.e. acts as a taker order<br />- `fok`: fill or kill, will be rejected if it is not fully filled<br />- `ioc`: immediate or cancel, fill at best bid/ask (market) or at limit price (limit), the unfilled portion is cancelled<br />Note that the order will still expire on the `signature_expiry_sec` timestamp.",
        title="time_in_force",
    )
    trigger_price: Optional[Decimal] = Field(
        None,
        description='(Required for trigger orders) "index" or "mark" price to trigger order at',
        title="trigger_price",
    )
    trigger_price_type: Optional[TriggerPriceType] = Field(
        None,
        description='(Required for trigger orders) Trigger with "mark" price as "index" price type not supported yet.',
        title="trigger_price_type",
    )
    trigger_type: Optional[TriggerType] = Field(
        None,
        description='(Required for trigger orders) "stoploss" or "takeprofit"',
        title="trigger_type",
    )


class RPCErrorFormatSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    code: int = Field(..., title="code")
    data: Optional[str] = Field(None, title="data")
    message: str = Field(..., title="message")


class PrivateCancelByInstrumentParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    instrument_name: str = Field(
        ...,
        description="Cancel all orders for this instrument",
        title="instrument_name",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


PrivateCancelByInstrumentResultSchema = PrivateCancelByNonceResultSchema


class PrivateCancelAllParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subaccount_id: int = Field(..., title="subaccount_id")


PrivateCancelAllResponseSchema = PrivateSetCancelOnDisconnectResponseSchema


class PublicDeregisterSessionKeyParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    signed_raw_tx: str = Field(
        ...,
        description="A signed RLP encoded ETH transaction in form of a hex string (same as `w3.eth.account.sign_transaction(unsigned_tx, private_key).rawTransaction.hex()`)",
        title="signed_raw_tx",
    )
    wallet: str = Field(
        ..., description="Ethereum wallet address of account", title="wallet"
    )


class PublicDeregisterSessionKeyResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    public_session_key: str = Field(
        ...,
        description="Session key in the form of an Ethereum EOA",
        title="public_session_key",
    )
    transaction_id: UUID = Field(
        ..., description="ID to lookup status of transaction", title="transaction_id"
    )


class PrivateWithdrawParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount: Decimal = Field(
        ..., description="Amount of the asset to withdraw", title="amount"
    )
    asset_name: str = Field(
        ..., description="Name of asset to withdraw", title="asset_name"
    )
    is_atomic_signing: bool = Field(
        False,
        description="Used by vaults to determine whether the signature is an EIP-1271 signature",
        title="is_atomic_signing",
    )
    nonce: int = Field(
        ...,
        description="Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)",
        title="nonce",
    )
    signature: str = Field(
        ..., description="Ethereum signature of the withdraw", title="signature"
    )
    signature_expiry_sec: int = Field(
        ...,
        description="Unix timestamp in seconds. Expiry MUST be >5min from now",
        title="signature_expiry_sec",
    )
    signer: str = Field(
        ...,
        description="Ethereum wallet address that is signing the withdraw",
        title="signer",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class PrivateWithdrawResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    status: str = Field(..., description="`requested`", title="status")
    transaction_id: UUID = Field(
        ..., description="Transaction id of the withdrawal", title="transaction_id"
    )


class PrivateGetNotificationsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    notifications: List[NotificationResponseSchema] = Field(
        ..., description="Notification response", title="notifications"
    )
    pagination: PaginationInfoSchema


PublicGetCurrencyResultSchema = CurrencyDetailedResponseSchema


class PrivateSetMmpConfigResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateSetMmpConfigResultSchema


class PrivateTransferPositionParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    maker_params: TradeModuleParamsSchema
    taker_params: TradeModuleParamsSchema
    wallet: str = Field(
        ..., description="Public key (wallet) of the account", title="wallet"
    )


class PrivateTransferPositionResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    maker_order: OrderResponseSchema
    maker_trade: TradeResponseSchema
    taker_order: OrderResponseSchema
    taker_trade: TradeResponseSchema


class PrivateCreateSubaccountResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCreateSubaccountResultSchema


class PrivateSendRfqParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    counterparties: Optional[List[str]] = Field(
        None,
        description="Optional list of market maker account addresses to request quotes from. If not supplied, all market makers who are approved as RFQ makers will be notified.",
        title="counterparties",
    )
    label: str = Field(
        "", description="Optional user-defined label for the RFQ", title="label"
    )
    legs: List[LegUnpricedSchema] = Field(..., description="RFQ legs", title="legs")
    max_total_cost: Optional[Decimal] = Field(
        None,
        description="An optional max total cost for the RFQ. Only used when the RFQ sender executes as buyer. Polling endpoints and channels will ignore quotes where the total cost across all legs is above this value. Positive values mean the RFQ sender expects to pay $, negative mean the RFQ sender expects to receive $.This field is not disclosed to the market makers.",
        title="max_total_cost",
    )
    min_total_cost: Optional[Decimal] = Field(
        None,
        description="An optional min total cost for the RFQ. Only used when the RFQ sender executes as seller. Polling endpoints and channels will ignore quotes where the total cost across all legs is below this value. Positive values mean the RFQ sender expects to receive $, negative mean the RFQ sender expects to pay $.This field is not disclosed to the market makers.",
        title="min_total_cost",
    )
    partial_fill_step: Decimal = Field(
        "1",
        description="Optional step size for partial fills. If not supplied, the RFQ will not support partial fills.",
        title="partial_fill_step",
    )
    subaccount_id: int = Field(..., description="Subaccount ID", title="subaccount_id")


class PrivateSendRfqResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateSendRfqResultSchema


class PublicMarginWatchResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    collaterals: List[CollateralPublicResponseSchema] = Field(
        ...,
        description="All collaterals that count towards margin of subaccount",
        title="collaterals",
    )
    currency: str = Field(..., description="Currency of subaccount", title="currency")
    initial_margin: Decimal = Field(
        ...,
        description="Total initial margin requirement of all positions and collaterals.",
        title="initial_margin",
    )
    maintenance_margin: Decimal = Field(
        ...,
        description="Total maintenance margin requirement of all positions and collaterals.If this value falls below zero, the subaccount will be flagged for liquidation.",
        title="maintenance_margin",
    )
    margin_type: MarginType = Field(
        ...,
        description="Margin type of subaccount (`PM` (Portfolio Margin), `PM2 (Portfolio Margin 2), or `SM` (Standard Margin))",
        title="margin_type",
    )
    positions: List[PositionPublicResponseSchema] = Field(
        ..., description="All active positions of subaccount", title="positions"
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")
    subaccount_value: Decimal = Field(
        ...,
        description="Total mark-to-market value of all positions and collaterals",
        title="subaccount_value",
    )
    valuation_timestamp: int = Field(
        ...,
        description="Timestamp (in seconds since epoch) of when margin and MtM were computed.",
        title="valuation_timestamp",
    )


class PublicStatisticsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicStatisticsResultSchema


class PrivateCancelResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelResultSchema


PrivateExecuteQuoteParamsSchema = PublicExecuteQuoteDebugParamsSchema


class PrivateExecuteQuoteResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateExecuteQuoteResultSchema


class PublicGetSpotFeedHistoryCandlesResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(..., description="Currency", title="currency")
    spot_feed_history: List[SpotFeedHistoryCandlesResponseSchema] = Field(
        ..., description="Spot feed history candles", title="spot_feed_history"
    )


class PrivatePollRfqsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    rfqs: List[RFQResultPublicSchema] = Field(
        ..., description="RFQs matching filter criteria", title="rfqs"
    )


class AuctionResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    auction_id: str = Field(
        ..., description="Unique ID of the auction", title="auction_id"
    )
    auction_type: AuctionType = Field(
        ..., description="Type of auction", title="auction_type"
    )
    bids: List[AuctionBidEventSchema] = Field(
        ..., description="List of auction bid events", title="bids"
    )
    end_timestamp: Optional[int] = Field(
        ...,
        description="Timestamp of the auction end (in ms since UNIX epoch), or `null` if not ended",
        title="end_timestamp",
    )
    fee: Decimal = Field(..., description="Fee paid by the subaccount", title="fee")
    start_timestamp: int = Field(
        ...,
        description="Timestamp of the auction start (in ms since UNIX epoch)",
        title="start_timestamp",
    )
    subaccount_id: int = Field(
        ..., description="Liquidated subaccount ID", title="subaccount_id"
    )
    tx_hash: str = Field(
        ...,
        description="Hash of the transaction that started the auction",
        title="tx_hash",
    )


class SignedTradeOrderSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    data: TradeModuleDataSchema
    expiry: int = Field(..., title="expiry")
    is_atomic_signing: bool = Field(..., title="is_atomic_signing")
    module: str = Field(..., title="module")
    nonce: int = Field(..., title="nonce")
    owner: str = Field(..., title="owner")
    signature: str = Field(..., title="signature")
    signer: str = Field(..., title="signer")
    subaccount_id: int = Field(..., title="subaccount_id")


class PrivateDepositResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateDepositResultSchema


class PrivateUpdateNotificationsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateUpdateNotificationsResultSchema


class PrivateChangeSubaccountLabelResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateChangeSubaccountLabelResultSchema


class PrivateTransferPositionsParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    maker_params: SignedQuoteParamsSchema
    taker_params: SignedQuoteParamsSchema
    wallet: str = Field(
        ..., description="Public key (wallet) of the account", title="wallet"
    )


class PrivateTransferPositionsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    maker_quote: QuoteResultSchema
    taker_quote: QuoteResultSchema


class PublicGetMakerProgramsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[ProgramResponseSchema] = Field(..., description="", title="result")


class PublicGetMarginParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    margin_type: MarginType = Field(
        ...,
        description="`PM` (Portfolio Margin), `PM2 (Portfolio Margin 2), or `SM` (Standard Margin))",
        title="margin_type",
    )
    market: Optional[str] = Field(
        None, description="Must be defined for Portfolio Margin", title="market"
    )
    simulated_collateral_changes: Optional[List[SimulatedCollateralSchema]] = Field(
        None,
        description="Optional, add collaterals to simulate deposits / withdrawals / spot trades",
        title="simulated_collateral_changes",
    )
    simulated_collaterals: List[SimulatedCollateralSchema] = Field(
        ...,
        description="List of collaterals in a simulated portfolio",
        title="simulated_collaterals",
    )
    simulated_position_changes: Optional[List[SimulatedPositionSchema]] = Field(
        None,
        description="Optional, add positions to simulate perp / option trades",
        title="simulated_position_changes",
    )
    simulated_positions: List[SimulatedPositionSchema] = Field(
        ...,
        description="List of positions in a simulated portfolio",
        title="simulated_positions",
    )


class PublicGetMarginResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetMarginResultSchema


class PrivateCancelByNonceResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelByNonceResultSchema


class PublicGetSpotFeedHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    currency: str = Field(..., description="Currency", title="currency")
    spot_feed_history: List[SpotFeedHistoryResponseSchema] = Field(
        ..., description="Spot feed history", title="spot_feed_history"
    )


class PrivateGetSubaccountsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetSubaccountsResultSchema


class PrivateGetDepositHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    events: List[DepositSchema] = Field(
        ..., description="List of deposit payments", title="events"
    )


class PrivateCancelByLabelResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelByLabelResultSchema


class PrivateGetMarginResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetMarginResultSchema


class PublicCreateSubaccountDebugResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicCreateSubaccountDebugResultSchema


PublicGetInstrumentResultSchema = InstrumentPublicResponseSchema


class PrivateEditSessionKeyResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateEditSessionKeyResultSchema


class PrivateGetLiquidatorHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetLiquidatorHistoryResultSchema


class PrivateGetPositionsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    positions: List[PositionResponseSchema] = Field(
        ..., description="All active positions of subaccount", title="positions"
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class PublicGetTradeHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    trades: List[TradeSettledPublicResponseSchema] = Field(
        ..., description="List of trades", title="trades"
    )


class PrivateGetRfqsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    rfqs: List[RFQResultSchema] = Field(
        ..., description="RFQs matching filter criteria", title="rfqs"
    )


class PrivateTransferErc20ParamsSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    recipient_details: SignatureDetailsSchema
    recipient_subaccount_id: int = Field(
        ...,
        description="Subaccount_id of the recipient",
        title="recipient_subaccount_id",
    )
    sender_details: SignatureDetailsSchema
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")
    transfer: TransferDetailsSchema


class PrivateTransferErc20ResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateTransferErc20ResultSchema


class PrivateSendQuoteResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateSendQuoteResultSchema


class PrivateCancelTriggerOrderResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelTriggerOrderResultSchema


class PrivateGetWithdrawalHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    events: List[WithdrawalSchema] = Field(
        ..., description="List of withdrawals", title="events"
    )


class PublicGetOptionSettlementPricesResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    expiries: List[ExpiryResponseSchema] = Field(
        ..., description="List of expiry details", title="expiries"
    )


class PublicGetMakerProgramScoresResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    program: ProgramResponseSchema
    scores: List[ScoreBreakdownSchema] = Field(
        ...,
        description="Scores breakdown of the program by market maker",
        title="scores",
    )
    total_score: Decimal = Field(
        ...,
        description="Total score across all market makers for the epoch",
        title="total_score",
    )
    total_volume: Decimal = Field(
        ...,
        description="Total volume across all market makers for the epoch",
        title="total_volume",
    )


class PublicBuildRegisterSessionKeyTxResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicBuildRegisterSessionKeyTxResultSchema


class PublicRegisterSessionKeyResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicRegisterSessionKeyResultSchema


class PrivateGetOrderHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetOrderHistoryResultSchema


class PrivateCancelBatchRfqsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelBatchRfqsResultSchema


class PrivateCancelBatchQuotesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelBatchQuotesResultSchema


class PrivateGetFundingHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    events: List[FundingPaymentSchema] = Field(
        ..., description="List of funding payments", title="events"
    )
    pagination: PaginationInfoSchema


class PrivateGetOpenOrdersResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetOpenOrdersResultSchema


class PrivateGetAccountResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancel_on_disconnect: bool = Field(
        ...,
        description="Whether cancel on disconnect is enabled for the account",
        title="cancel_on_disconnect",
    )
    fee_info: AccountFeeInfoSchema
    is_rfq_maker: bool = Field(
        ...,
        description="Whether account allowed to market make RFQs",
        title="is_rfq_maker",
    )
    per_endpoint_tps: Dict[str, Any] = Field(
        ...,
        description="If a particular endpoint has a different max TPS, it will be specified here",
        title="per_endpoint_tps",
    )
    referral_code: Optional[str] = Field(
        None,
        description="Referral code for the account (must register with broker program first)",
        title="referral_code",
    )
    subaccount_ids: List[int] = Field(
        ...,
        description="List of subaccount_ids owned by the wallet in `SubAccounts.sol`",
        title="subaccount_ids",
    )
    wallet: str = Field(..., description="Ethereum wallet address", title="wallet")
    websocket_matching_tps: int = Field(
        ...,
        description="Max transactions per second for matching requests over websocket (see `Rate Limiting` in docs)",
        title="websocket_matching_tps",
    )
    websocket_non_matching_tps: int = Field(
        ...,
        description="Max transactions per second for non-matching requests over websocket (see `Rate Limiting` in docs)",
        title="websocket_non_matching_tps",
    )
    websocket_option_tps: int = Field(
        ...,
        description="Max transactions per second for EACH option instrument over websocket (see `Rate Limiting` in docs)",
        title="websocket_option_tps",
    )
    websocket_perp_tps: int = Field(
        ...,
        description="Max transactions per second for EACH perp instrument over websocket (see `Rate Limiting` in docs)",
        title="websocket_perp_tps",
    )


class PublicGetAllInstrumentsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    instruments: List[InstrumentPublicResponseSchema] = Field(
        ..., description="List of instruments", title="instruments"
    )
    pagination: PaginationInfoSchema


class PublicGetTickerResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    amount_step: Decimal = Field(
        ..., description="Minimum valid increment of order amount", title="amount_step"
    )
    base_asset_address: str = Field(
        ...,
        description="Blockchain address of the base asset",
        title="base_asset_address",
    )
    base_asset_sub_id: str = Field(
        ...,
        description="Sub ID of the specific base asset as defined in Asset.sol",
        title="base_asset_sub_id",
    )
    base_currency: str = Field(
        ...,
        description="Underlying currency of base asset (`ETH`, `BTC`, etc)",
        title="base_currency",
    )
    base_fee: Decimal = Field(
        ..., description="$ base fee added to every taker order", title="base_fee"
    )
    best_ask_amount: Decimal = Field(
        ...,
        description="Amount of contracts / tokens available at best ask price",
        title="best_ask_amount",
    )
    best_ask_price: Decimal = Field(
        ..., description="Best ask price", title="best_ask_price"
    )
    best_bid_amount: Decimal = Field(
        ...,
        description="Amount of contracts / tokens available at best bid price",
        title="best_bid_amount",
    )
    best_bid_price: Decimal = Field(
        ..., description="Best bid price", title="best_bid_price"
    )
    erc20_details: Optional[ERC20PublicDetailsSchema] = Field(...)
    fifo_min_allocation: Decimal = Field(
        ...,
        description="Minimum number of contracts that get filled using FIFO. Actual number of contracts that gets filled by FIFO will be the max between this value and (1 - pro_rata_fraction) x order_amount, plus any size leftovers due to rounding.",
        title="fifo_min_allocation",
    )
    five_percent_ask_depth: Decimal = Field(
        ...,
        description="Total amount of contracts / tokens available at 5 percent above best ask price",
        title="five_percent_ask_depth",
    )
    five_percent_bid_depth: Decimal = Field(
        ...,
        description="Total amount of contracts / tokens available at 5 percent below best bid price",
        title="five_percent_bid_depth",
    )
    index_price: Decimal = Field(..., description="Index price", title="index_price")
    instrument_name: str = Field(
        ..., description="Instrument name", title="instrument_name"
    )
    instrument_type: InstrumentType = Field(
        ..., description="`erc20`, `option`, or `perp`", title="instrument_type"
    )
    is_active: bool = Field(
        ...,
        description="If `True`: instrument is tradeable within `activation` and `deactivation` timestamps",
        title="is_active",
    )
    maker_fee_rate: Decimal = Field(
        ...,
        description="Percent of spot price fee rate for makers",
        title="maker_fee_rate",
    )
    mark_price: Decimal = Field(..., description="Mark price", title="mark_price")
    mark_price_fee_rate_cap: Optional[Decimal] = Field(
        None,
        description="Percent of option price fee cap, e.g. 12.5%, null if not applicable",
        title="mark_price_fee_rate_cap",
    )
    max_price: Decimal = Field(
        ...,
        description="Maximum price at which an agressive buyer can be matched. Any portion of a market order that would execute above this price will be cancelled. A limit buy order with limit price above this value is treated as post only (i.e. it will be rejected if it would cross any existing resting order).",
        title="max_price",
    )
    maximum_amount: Decimal = Field(
        ...,
        description="Maximum valid amount of contracts / tokens per trade",
        title="maximum_amount",
    )
    min_price: Decimal = Field(
        ...,
        description="Minimum price at which an agressive seller can be matched. Any portion of a market order that would execute below this price will be cancelled. A limit sell order with limit price below this value is treated as post only (i.e. it will be rejected if it would cross any existing resting order).",
        title="min_price",
    )
    minimum_amount: Decimal = Field(
        ...,
        description="Minimum valid amount of contracts / tokens per trade",
        title="minimum_amount",
    )
    open_interest: Dict[str, List[OpenInterestStatsSchema]] = Field(
        ...,
        description="Margin type of subaccount (`PM` (Portfolio Margin), `PM2 (Portfolio Margin 2), or `SM` (Standard Margin)) -> (current open interest, open interest cap, manager currency)",
        title="open_interest",
    )
    option_details: Optional[OptionPublicDetailsSchema] = Field(...)
    option_pricing: Optional[OptionPricingSchema] = Field(...)
    perp_details: Optional[PerpPublicDetailsSchema] = Field(...)
    pro_rata_amount_step: Decimal = Field(
        ...,
        description="Pro-rata fill share of every order is rounded down to be a multiple of this number. Leftovers of the order due to rounding are filled FIFO.",
        title="pro_rata_amount_step",
    )
    pro_rata_fraction: Decimal = Field(
        ...,
        description="Fraction of order that gets filled using pro-rata matching. If zero, the matching is full FIFO.",
        title="pro_rata_fraction",
    )
    quote_currency: str = Field(
        ...,
        description="Quote currency (`USD` for perps, `USDC` for options)",
        title="quote_currency",
    )
    scheduled_activation: int = Field(
        ...,
        description="Timestamp at which became or will become active (if applicable)",
        title="scheduled_activation",
    )
    scheduled_deactivation: int = Field(
        ...,
        description="Scheduled deactivation time for instrument (if applicable)",
        title="scheduled_deactivation",
    )
    stats: AggregateTradingStatsSchema
    taker_fee_rate: Decimal = Field(
        ...,
        description="Percent of spot price fee rate for takers",
        title="taker_fee_rate",
    )
    tick_size: Decimal = Field(
        ...,
        description="Tick size of the instrument, i.e. minimum price increment",
        title="tick_size",
    )
    timestamp: int = Field(
        ..., description="Timestamp of the ticker feed snapshot", title="timestamp"
    )


class PublicGetVaultShareResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    vault_shares: List[VaultShareResponseSchema] = Field(
        ...,
        description="List of vault history shares, recent first",
        title="vault_shares",
    )


class PrivateGetCollateralsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    collaterals: List[CollateralResponseSchema] = Field(
        ...,
        description="All collaterals that count towards margin of subaccount",
        title="collaterals",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")


class PrivateRegisterScopedSessionKeyResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateRegisterScopedSessionKeyResultSchema


class PrivateExpiredAndCancelledHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateExpiredAndCancelledHistoryResultSchema


class PrivateSessionKeysResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    public_session_keys: List[SessionKeyResponseSchema] = Field(
        ...,
        description="List of session keys (includes unactivated and expired keys)",
        title="public_session_keys",
    )


class PrivateGetMmpConfigResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[MMPConfigResultSchema] = Field(..., description="", title="result")


class PrivateOrderResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateOrderResultSchema


class PrivateGetSubaccountResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetSubaccountResultSchema


class PublicGetInterestRateHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    interest_rates: List[InterestRateHistoryResponseSchema] = Field(
        ..., description="List of interest rates, recent first", title="interest_rates"
    )
    pagination: PaginationInfoSchema


class PublicGetLiquidationHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    auctions: List[AuctionResultSchema] = Field(
        ..., description="List of auction results", title="auctions"
    )
    pagination: PaginationInfoSchema


class PublicDepositDebugResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicDepositDebugResultSchema


class PublicGetVaultBalancesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[VaultBalanceResponseSchema] = Field(
        ..., description="", title="result"
    )


class PublicGetReferralPerformanceResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fee_share_percentage: Decimal = Field(
        ...,
        description="Fee share percentage rewarded to referrer",
        title="fee_share_percentage",
    )
    referral_code: str = Field(
        ..., description="Referral code used to get performance", title="referral_code"
    )
    rewards: Dict[
        str, Dict[str, Dict[str, ReferralPerformanceByInstrumentTypeSchema]]
    ] = Field(
        ...,
        description="Performance by liquidity role / currency / instrument type",
        title="rewards",
    )
    stdrv_balance: Decimal = Field(
        ...,
        description="Staked DRV held used to determine fee share percentage",
        title="stdrv_balance",
    )
    total_fee_rewards: Decimal = Field(
        ..., description="Total fee rewards to referrers", title="total_fee_rewards"
    )
    total_notional_volume: Decimal = Field(
        ..., description="Total referred notional volume", title="total_notional_volume"
    )
    total_referred_fees: Decimal = Field(
        ...,
        description="Total fees paid by referred traders (double counts if both taker and maker of a trade with rebated fees)",
        title="total_referred_fees",
    )


class PrivateCancelQuoteResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelQuoteResultSchema


class PrivateGetQuotesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetQuotesResultSchema


class PublicExecuteQuoteDebugResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicExecuteQuoteDebugResultSchema


class PrivateGetOptionSettlementHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    settlements: List[OptionSettlementResponseSchema] = Field(
        ..., description="List of expired option settlements", title="settlements"
    )
    subaccount_id: int = Field(
        ...,
        description="Subaccount_id for which to get expired option settlement history",
        title="subaccount_id",
    )


class PrivateGetErc20TransferHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    events: List[ERC20TransferSchema] = Field(
        ..., description="List of erc20 transfers", title="events"
    )


class PublicGetAllCurrenciesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[CurrencyDetailedResponseSchema] = Field(
        ..., description="", title="result"
    )


class PrivateGetSubaccountValueHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subaccount_id: int = Field(..., description="Subaccount_id", title="subaccount_id")
    subaccount_value_history: List[SubAccountValueHistoryResponseSchema] = Field(
        ..., description="Subaccount value history", title="subaccount_value_history"
    )


class PublicSendQuoteDebugResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicSendQuoteDebugResultSchema


class PublicGetLiveIncidentsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    incidents: List[IncidentResponseSchema] = Field(
        ..., description="List of ongoing incidents", title="incidents"
    )


class PublicGetTransactionResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetTransactionResultSchema


class PrivateGetOrdersResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetOrdersResultSchema


class PrivateGetInterestHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    events: List[InterestPaymentSchema] = Field(
        ..., description="List of interest payments", title="events"
    )


class PrivatePollQuotesResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    pagination: PaginationInfoSchema
    quotes: List[QuoteResultPublicSchema] = Field(
        ..., description="Quotes matching filter criteria", title="quotes"
    )


class PrivateGetOrderResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetOrderResultSchema


class PublicGetVaultStatisticsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[VaultStatisticsResponseSchema] = Field(
        ..., description="", title="result"
    )


class PublicWithdrawDebugResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicWithdrawDebugResultSchema


class PublicGetFundingRateHistoryResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    funding_rate_history: List[FundingRateSchema] = Field(
        ..., description="List of funding rates", title="funding_rate_history"
    )


class PrivateRfqGetBestQuoteResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateRfqGetBestQuoteResultSchema


class PublicGetOptionSettlementHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetOptionSettlementHistoryResultSchema


class PrivateLiquidateResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateLiquidateResultSchema


class PrivateGetTradeHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetTradeHistoryResultSchema


class ForwardFeedDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    confidence: Decimal = Field(
        ..., description="The confidence score of the price", title="confidence"
    )
    currency: str = Field(
        ...,
        description="The currency for which the spot feed represents",
        title="currency",
    )
    deadline: int = Field(
        ...,
        description="The latest time the data can be submitted on chain",
        title="deadline",
    )
    expiry: int = Field(
        ..., description="The expiry for the forward feed", title="expiry"
    )
    fwd_diff: Decimal = Field(
        ...,
        description="difference of forward price from current spot price",
        title="fwd_diff",
    )
    signatures: OracleSignatureDataSchema
    spot_aggregate_latest: Decimal = Field(
        ...,
        description="expiry -> spot * time value at the latest timestamp",
        title="spot_aggregate_latest",
    )
    spot_aggregate_start: Decimal = Field(
        ...,
        description="spot * time value at the start of the settlement period",
        title="spot_aggregate_start",
    )
    timestamp: int = Field(
        ...,
        description="The timestamp for which the data was created",
        title="timestamp",
    )


class VolFeedDataSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    confidence: Decimal = Field(
        ..., description="The confidence score of the price", title="confidence"
    )
    currency: str = Field(
        ...,
        description="The currency for which the spot feed represents",
        title="currency",
    )
    deadline: int = Field(
        ...,
        description="The latest time the data can be submitted on chain",
        title="deadline",
    )
    expiry: int = Field(
        ..., description="The expiry for the options for the vol feed", title="expiry"
    )
    signatures: OracleSignatureDataSchema
    timestamp: int = Field(
        ...,
        description="The timestamp for which the data was created",
        title="timestamp",
    )
    vol_data: VolSVIParamDataSchema


class PrivateReplaceResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    cancelled_order: OrderResponseSchema
    create_order_error: Optional[RPCErrorFormatSchema] = None
    order: Optional[OrderResponseSchema] = None
    trades: Optional[List[TradeResponseSchema]] = Field(
        None, description="List of trades executed by the created order", title="trades"
    )


class PrivateCancelByInstrumentResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateCancelByInstrumentResultSchema


class PublicDeregisterSessionKeyResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicDeregisterSessionKeyResultSchema


class PrivateWithdrawResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateWithdrawResultSchema


class PrivateGetNotificationsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetNotificationsResultSchema


class PublicGetCurrencyResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetCurrencyResultSchema


class PrivateTransferPositionResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateTransferPositionResultSchema


class PublicMarginWatchResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicMarginWatchResultSchema


class PublicGetSpotFeedHistoryCandlesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetSpotFeedHistoryCandlesResultSchema


class PrivatePollRfqsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivatePollRfqsResultSchema


class PrivateGetLiquidationHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: List[AuctionResultSchema] = Field(..., description="", title="result")


class PrivateOrderDebugResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    action_hash: str = Field(
        ..., description="Keccak hashed action data", title="action_hash"
    )
    encoded_data: str = Field(
        ..., description="ABI encoded order data", title="encoded_data"
    )
    encoded_data_hashed: str = Field(
        ..., description="Keccak hashed encoded_data", title="encoded_data_hashed"
    )
    raw_data: SignedTradeOrderSchema
    typed_data_hash: str = Field(
        ..., description="EIP 712 typed data hash", title="typed_data_hash"
    )


class PrivateTransferPositionsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateTransferPositionsResultSchema


class PublicGetSpotFeedHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetSpotFeedHistoryResultSchema


class PrivateGetDepositHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetDepositHistoryResultSchema


class PublicGetInstrumentResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetInstrumentResultSchema


class PrivateGetPositionsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetPositionsResultSchema


class PublicGetTradeHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetTradeHistoryResultSchema


class PrivateGetRfqsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetRfqsResultSchema


class PrivateGetWithdrawalHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetWithdrawalHistoryResultSchema


class PublicGetOptionSettlementPricesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetOptionSettlementPricesResultSchema


class PublicGetMakerProgramScoresResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetMakerProgramScoresResultSchema


class PrivateGetFundingHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetFundingHistoryResultSchema


class PrivateGetAccountResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetAccountResultSchema


class PublicGetAllInstrumentsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetAllInstrumentsResultSchema


class PublicGetTickerResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetTickerResultSchema


class PublicGetVaultShareResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetVaultShareResultSchema


class PrivateGetCollateralsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetCollateralsResultSchema


class PrivateSessionKeysResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateSessionKeysResultSchema


class PublicGetInterestRateHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetInterestRateHistoryResultSchema


class PublicGetLiquidationHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetLiquidationHistoryResultSchema


class PublicGetReferralPerformanceResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetReferralPerformanceResultSchema


class PrivateGetOptionSettlementHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetOptionSettlementHistoryResultSchema


class PrivateGetErc20TransferHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetErc20TransferHistoryResultSchema


class PrivateGetSubaccountValueHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetSubaccountValueHistoryResultSchema


class PublicGetLiveIncidentsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetLiveIncidentsResultSchema


class PrivateGetInterestHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateGetInterestHistoryResultSchema


class PrivatePollQuotesResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivatePollQuotesResultSchema


class PublicGetFundingRateHistoryResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetFundingRateHistoryResultSchema


class PublicGetLatestSignedFeedsResultSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fwd_data: Dict[str, Dict[str, ForwardFeedDataSchema]] = Field(
        ...,
        description="currency -> expiry -> latest forward feed data",
        title="fwd_data",
    )
    perp_data: Dict[str, Dict[str, PerpFeedDataSchema]] = Field(
        ...,
        description="currency -> feed type -> latest perp feed data",
        title="perp_data",
    )
    rate_data: Dict[str, Dict[str, RateFeedDataSchema]] = Field(
        ...,
        description="currency -> expiry -> latest rate feed data",
        title="rate_data",
    )
    spot_data: Dict[str, SpotFeedDataSchema] = Field(
        ..., description="currency -> latest spot feed data", title="spot_data"
    )
    vol_data: Dict[str, Dict[str, VolFeedDataSchema]] = Field(
        ..., description="currency -> expiry -> latest vol feed data", title="vol_data"
    )


class PrivateReplaceResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateReplaceResultSchema


class PrivateOrderDebugResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PrivateOrderDebugResultSchema


class PublicGetLatestSignedFeedsResponseSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: Union[str, int]
    result: PublicGetLatestSignedFeedsResultSchema
